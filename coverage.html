
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aql: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ceresdb/aql/add.go (0.0%)</option>
				
				<option value="file1">ceresdb/aql/aql.go (50.8%)</option>
				
				<option value="file2">ceresdb/aql/create.go (0.0%)</option>
				
				<option value="file3">ceresdb/aql/delete.go (0.0%)</option>
				
				<option value="file4">ceresdb/aql/get.go (0.0%)</option>
				
				<option value="file5">ceresdb/aql/insert.go (0.0%)</option>
				
				<option value="file6">ceresdb/aql/update.go (0.0%)</option>
				
				<option value="file7">ceresdb/auth/auth.go (100.0%)</option>
				
				<option value="file8">ceresdb/collection/collection.go (83.2%)</option>
				
				<option value="file9">ceresdb/config/config.go (50.7%)</option>
				
				<option value="file10">ceresdb/database/database.go (81.4%)</option>
				
				<option value="file11">ceresdb/index/index.go (71.2%)</option>
				
				<option value="file12">ceresdb/record/record.go (60.7%)</option>
				
				<option value="file13">ceresdb/schema/schema.go (68.0%)</option>
				
				<option value="file14">ceresdb/utils/utils.go (46.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/collection"
        "ceresdb/constants"
        "ceresdb/database"
        "ceresdb/query"
        "ceresdb/utils"
        "fmt"
        "strings"
)

func processAdd(q string, tokens []string, u auth.User) error <span class="cov0" title="0">{
        noun := strings.ToUpper(tokens[0])
        switch noun </span>{
        case constants.NOUN_GROUP:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 4 </span><span class="cov0" title="0">{
                        return processAddGroupUser(q, args, u)
                }</span>
                <span class="cov0" title="0">if len(args) == 6 </span><span class="cov0" title="0">{
                        if len(strings.Split(args[5], ".")) == 2 </span><span class="cov0" title="0">{
                                return processAddGroupPermissionCollection(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processAddGroupPermissionDatabase(q, args, u)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_ADD, noun, q)</span>
        case constants.NOUN_ROLE:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 4 </span><span class="cov0" title="0">{
                        return processAddRoleUser(q, args, u)
                }</span>
                <span class="cov0" title="0">if len(args) == 6 </span><span class="cov0" title="0">{
                        if len(strings.Split(args[5], ".")) == 2 </span><span class="cov0" title="0">{
                                return processAddRolePermissionCollection(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processAddRolePermissionDatabase(q, args, u)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_ADD, noun, q)</span>
        case constants.NOUN_USER:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 6 </span><span class="cov0" title="0">{
                        if len(strings.Split(args[5], ".")) == 2 </span><span class="cov0" title="0">{
                                return processAddUserPermissionCollection(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processAddUserPermissionDatabase(q, args, u)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_ADD, noun, q)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid query: unknown noun '%s': %s", noun, q)</span>
}

func processAddGroupUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_TO, constants.NOUN_USER, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">uu, err := query.GetUser(args[3], u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uu.Groups = append(uu.Groups, args[0])
        uu.Groups = utils.RemoveDuplicateValues(uu.Groups)
        if err := query.UpdateUser(args[3], uu, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func processAddGroupPermissionCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PERMISSION, "", constants.PREPOSITION_TO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[5], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.AddGroupAuth(parts[0], parts[1], args[0], args[3])</span>
}

func processAddGroupPermissionDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PERMISSION, "", constants.PREPOSITION_TO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.VerifyAuth(args[5], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.AddGroupAuth(args[5], args[0], args[3])</span>
}

func processAddRoleUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_TO, constants.NOUN_USER, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">uu, err := query.GetUser(args[3], u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uu.Roles = append(uu.Roles, args[0])
        uu.Roles = utils.RemoveDuplicateValues(uu.Roles)
        if err := query.UpdateUser(args[3], uu, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func processAddRolePermissionCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PERMISSION, "", constants.PREPOSITION_TO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[5], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.AddRoleAuth(parts[0], parts[1], args[0], args[3])</span>
}

func processAddRolePermissionDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PERMISSION, "", constants.PREPOSITION_TO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.VerifyAuth(args[5], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.AddRoleAuth(args[5], args[0], args[3])</span>
}

func processAddUserPermissionCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PERMISSION, "", constants.PREPOSITION_TO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[5], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.AddUserAuth(parts[0], parts[1], args[0], args[3])</span>
}

func processAddUserPermissionDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PERMISSION, "", constants.PREPOSITION_TO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.VerifyAuth(args[5], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.AddUserAuth(args[5], args[0], args[3])</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/constants"
        "fmt"
        "strings"
)

/*
* ADD GROUP &lt;group&gt; TO USER &lt;user&gt;
* ADD GROUP &lt;group&gt; WITH PERMISSION &lt;permission&gt; TO &lt;db&gt;
* ADD GROUP &lt;group&gt; WITH PERMISSION &lt;permission&gt; TO &lt;db&gt;.&lt;collection&gt;
* ADD ROLE &lt;role&gt; TO USER &lt;user&gt;
* ADD ROLE &lt;role&gt; WITH PERMISSION &lt;permission&gt; TO &lt;db&gt;
* ADD ROLE &lt;role&gt; WITH PERMISSION &lt;permission&gt; TO &lt;db&gt;.&lt;collection&gt;
* ADD USER &lt;user&gt; WITH PERMISSION &lt;permission&gt; TO &lt;db&gt;
* ADD USER &lt;user&gt; WITH PERMISSION &lt;permission&gt; TO &lt;db&gt;.&lt;collection&gt;

* CREATE COLLECTION &lt;collection&gt; IN &lt;db&gt; WITH SCHEMA &lt;json&gt;
* CREATE DATABASE &lt;db&gt;
* CREATE USER &lt;username&gt; WITH PASSWORD &lt;password&gt;

* DELETE COLLECTION &lt;collection&gt; FROM &lt;database&gt;
* DELETE DATABASE &lt;db&gt;
* DELETE GROUP &lt;group&gt; FROM &lt;db&gt;
* DELETE GROUP &lt;group&gt; FROM &lt;db&gt;.&lt;collection&gt;
* DELETE GROUP &lt;group&gt; FROM USER &lt;user&gt;
* DELETE RECORD FROM &lt;db&gt;.&lt;collection&gt; WHERE &lt;filter&gt;
* DELETE ROLE &lt;role&gt; FROM &lt;db&gt;
* DELETE ROLE &lt;role&gt; FROM &lt;db&gt;.&lt;collection&gt;
* DELETE ROLE &lt;role&gt; FROM USER &lt;user&gt;
* DELETE USER &lt;user&gt;
* DELETE USER &lt;user&gt; FROM &lt;db&gt;
* DELETE USER &lt;user&gt; FROM &lt;db&gt;.&lt;collection&gt;

* GET COLLECTION FROM &lt;database&gt;
* GET DATABASE
* GET RECORD FROM &lt;db&gt;.&lt;collection&gt;
* GET RECORD FROM &lt;db&gt;.&lt;collection&gt; WHERE &lt;filter&gt;
  GET RECORD FROM &lt;db&gt;.&lt;collection&gt; ORDERED BY &lt;field&gt;
  GET RECORD FROM &lt;db&gt;.&lt;collection&gt; WHERE &lt;filter&gt; ORDERED BY &lt;field&gt;
* GET SCHEMA &lt;collection&gt; FROM &lt;database&gt;
* GET USER

* INSERT RECORD &lt;json&gt; INTO &lt;db&gt;.&lt;collection&gt;

* UPDATE GROUP &lt;group&gt; PERMISSION TO &lt;permission&gt; IN &lt;db&gt;.&lt;collection&gt;
* UPDATE RECORD &lt;db&gt;.&lt;collection&gt; WITH &lt;json to update&gt; WHERE &lt;filter&gt;
* UPDATE ROLE &lt;role&gt; PERMISSION TO &lt;permission&gt; IN &lt;db&gt;.&lt;collection&gt;
* UPDATE USER &lt;user&gt; PERMISSION TO &lt;permission&gt; IN &lt;db&gt;.&lt;collection&gt;
* UPDATE USER &lt;username&gt; WITH PASSWORD &lt;password&gt;
*/

func ProcessQuery(q string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        tokens := breakTokens(q)

        if len(tokens) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: length 0: %s", q)
        }</span>
        <span class="cov0" title="0">if len(tokens) == 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: missing noun: %s, %v", q, tokens)
        }</span>

        <span class="cov0" title="0">verb := strings.ToUpper(tokens[0])
        switch verb </span>{
        case constants.VERB_ADD:<span class="cov0" title="0">
                err := processAdd(q, tokens[1:], u)
                return nil, err</span>
        case constants.VERB_CREATE:<span class="cov0" title="0">
                err := processCreate(q, tokens[1:], u)
                return nil, err</span>
        case constants.VERB_DELETE:<span class="cov0" title="0">
                err := processDelete(q, tokens[1:], u)
                return nil, err</span>
        case constants.VERB_GET:<span class="cov0" title="0">
                out, err := processGet(q, tokens[1:], u)
                return out, err</span>
        case constants.VERB_INSERT:<span class="cov0" title="0">
                err := processInsert(q, tokens[1:], u)
                return nil, err</span>
        case constants.VERB_UPDATE:<span class="cov0" title="0">
                err := processUpdate(q, tokens[1:], u)
                return nil, err</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: unknown verb: %s", q)</span>
}

func breakTokens(queryString string) []string <span class="cov8" title="1">{
        output := []string{}
        buffer := ""
        braceDepth := 0
        parenDepth := 0
        quoteDepth := 0
        bracketDepth := 0
        runes := []rune(queryString)
        lookBehind := ' '
        for _, r := range runes </span><span class="cov8" title="1">{
                if lookBehind != '\\' </span><span class="cov8" title="1">{
                        switch r </span>{
                        case '{':<span class="cov8" title="1">
                                if parenDepth+quoteDepth+bracketDepth == 0 </span><span class="cov8" title="1">{
                                        braceDepth += 1
                                }</span>
                                <span class="cov8" title="1">buffer += string(r)</span>
                        case '}':<span class="cov8" title="1">
                                if parenDepth+quoteDepth+bracketDepth == 0 </span><span class="cov8" title="1">{
                                        braceDepth -= 1
                                }</span>
                                <span class="cov8" title="1">buffer += string(r)</span>
                        case '(':<span class="cov0" title="0">
                                if braceDepth+quoteDepth+bracketDepth == 0 </span><span class="cov0" title="0">{
                                        parenDepth += 1
                                }</span>
                                <span class="cov0" title="0">buffer += string(r)</span>
                        case ')':<span class="cov0" title="0">
                                if braceDepth+quoteDepth+bracketDepth == 0 </span><span class="cov0" title="0">{
                                        parenDepth -= 1
                                }</span>
                                <span class="cov0" title="0">buffer += string(r)</span>
                        case '[':<span class="cov8" title="1">
                                if parenDepth+quoteDepth+braceDepth == 0 </span><span class="cov0" title="0">{
                                        bracketDepth += 1
                                }</span>
                                <span class="cov8" title="1">buffer += string(r)</span>
                        case ']':<span class="cov8" title="1">
                                if parenDepth+quoteDepth+braceDepth == 0 </span><span class="cov0" title="0">{
                                        bracketDepth -= 1
                                }</span>
                                <span class="cov8" title="1">buffer += string(r)</span>
                        case '"':<span class="cov8" title="1">
                                if parenDepth+braceDepth+bracketDepth == 0 </span><span class="cov0" title="0">{
                                        quoteDepth = -(quoteDepth - 1)
                                }</span>
                                <span class="cov8" title="1">buffer += string(r)</span>
                        case ' ':<span class="cov8" title="1">
                                if parenDepth+braceDepth+bracketDepth+quoteDepth == 0 </span><span class="cov8" title="1">{
                                        output = append(output, buffer)
                                        buffer = ""
                                }</span>
                        default:<span class="cov8" title="1">
                                buffer += string(r)</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov0" title="0">buffer += string(r)</span>
        }
        <span class="cov8" title="1">if len(buffer) &gt; 0 </span><span class="cov8" title="1">{
                output = append(output, buffer)
        }</span>
        <span class="cov8" title="1">return output</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/constants"
        "ceresdb/database"
        "ceresdb/index"
        "ceresdb/logger"
        "ceresdb/query"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "strings"
)

func processCreate(q string, tokens []string, u auth.User) error <span class="cov0" title="0">{
        noun := strings.ToUpper(tokens[0])
        switch noun </span>{
        case constants.NOUN_COLLECTION:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 6 </span><span class="cov0" title="0">{
                        return processCreateCollection(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_CREATE, noun, q)</span>
        case constants.NOUN_DATABASE:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 1 </span><span class="cov0" title="0">{
                        return processCreateDatabase(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_CREATE, noun, q)</span>
        case constants.NOUN_USER:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 4 </span><span class="cov0" title="0">{
                        return processCreateUser(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_CREATE, noun, q)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid query: unknown noun '%s': %s", noun, q)</span>
}

func processCreateCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        logger.Debugf("", "Processing create collection query: %v", args)
        logger.Tracef("", "Verifying syntax")
        check := []string{"", constants.PREPOSITION_IN, "", constants.PREPOSITION_WITH, constants.NOUN_SCHEMA, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">logger.Tracef("", "Creating collection")
        if err := database.AddCollection(args[2], args[0], u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := query.CreateCollection(args[2], args[0], u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Tracef("", "Unmarshalling schema")
        var s interface{}
        if err := json.Unmarshal([]byte(args[5]), &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Tracef("", "Building schema: %v", s)
        if err := query.BuildSchema(args[2], args[0], s, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">index.BuildIndex(args[2], args[0])
        return nil</span>
}

func processCreateDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">return query.CreateDatabase(args[0], u)</span>
}

func processCreateUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PASSWORD, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">return query.CreateUser(args[0], args[3], u, false)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/collection"
        "ceresdb/constants"
        "ceresdb/database"
        "ceresdb/query"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "strings"
)

func processDelete(q string, tokens []string, u auth.User) error <span class="cov0" title="0">{
        noun := strings.ToUpper(tokens[0])
        switch noun </span>{
        case constants.NOUN_COLLECTION:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 3 </span><span class="cov0" title="0">{
                        return processDeleteCollection(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_DELETE, noun, q)</span>
        case constants.NOUN_DATABASE:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 1 </span><span class="cov0" title="0">{
                        return processDeleteDatabase(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_DELETE, noun, q)</span>
        case constants.NOUN_RECORD:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 4 </span><span class="cov0" title="0">{
                        return processDeleteRecord(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_DELETE, noun, q)</span>
        case constants.NOUN_GROUP:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 3 </span><span class="cov0" title="0">{
                        if len(strings.Split(args[2], ".")) == 2 </span><span class="cov0" title="0">{
                                return processDeleteGroupPermissionCollection(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processDeleteGroupPermissionDatabase(q, args, u)</span>
                }
                <span class="cov0" title="0">if len(args) == 4 </span><span class="cov0" title="0">{
                        return processDeleteGroupUser(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_DELETE, noun, q)</span>
        case constants.NOUN_ROLE:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 3 </span><span class="cov0" title="0">{
                        if len(strings.Split(args[2], ".")) == 2 </span><span class="cov0" title="0">{
                                return processDeleteRolePermissionCollection(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processDeleteRolePermissionDatabase(q, args, u)</span>
                }
                <span class="cov0" title="0">if len(args) == 4 </span><span class="cov0" title="0">{
                        return processDeleteRoleUser(q, args, u)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_DELETE, noun, q)</span>
        case constants.NOUN_USER:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 1 </span><span class="cov0" title="0">{
                        return processDeleteUser(q, args, u)
                }</span>
                <span class="cov0" title="0">if len(args) == 3 </span><span class="cov0" title="0">{
                        if len(strings.Split(args[2], ".")) == 2 </span><span class="cov0" title="0">{
                                return processDeleteUserPermissionCollection(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processDeleteUserPermissionDatabase(q, args, u)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_DELETE, noun, q)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid query: unknown noun '%s': %s", noun, q)</span>
}

func processDeleteCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.DeleteCollection(args[2], args[0], u); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return query.DeleteCollection(args[2], args[0], u)</span>
}

func processDeleteDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">for _, col := range database.Databases[args[0]].Collections </span><span class="cov0" title="0">{
                if err := collection.Delete(args[0], col); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return query.DeleteDatabase(args[0], u)</span>
}

func processDeleteRecord(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, "", constants.PREPOSITION_WHERE, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">var f map[string]interface{}
        if err := json.Unmarshal([]byte(args[3]), &amp;f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                return query.DeleteRecordIndex(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], f, u)
        }</span>
        <span class="cov0" title="0">return query.DeleteRecordIndex(parts[0], parts[1], f, u)</span>
}

func processDeleteUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">return query.DeleteUser(args[0], u)</span>
}

func processDeleteGroupUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, constants.NOUN_USER, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">uu, err := query.GetUser(args[3], u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uu.Groups = utils.Remove(uu.Groups, args[0])
        if err := query.UpdateUser(args[3], uu, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func processDeleteGroupPermissionCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[2], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.DeleteGroupAuth(parts[0], parts[1], args[0])</span>
}

func processDeleteGroupPermissionDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.VerifyAuth(args[2], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.DeleteGroupAuth(args[2], args[0])</span>
}

func processDeleteRoleUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, constants.NOUN_USER, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">uu, err := query.GetUser(args[3], u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uu.Roles = utils.Remove(uu.Roles, args[0])
        if err := query.UpdateUser(args[3], uu, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func processDeleteRolePermissionCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[2], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.DeleteRoleAuth(parts[0], parts[1], args[0])</span>
}

func processDeleteRolePermissionDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.VerifyAuth(args[2], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.DeleteRoleAuth(args[2], args[0])</span>
}

func processDeleteUserPermissionCollection(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[2], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.DeleteUserAuth(parts[0], parts[1], args[0])</span>
}

func processDeleteUserPermissionDatabase(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := database.VerifyAuth(args[2], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.DeleteUserAuth(args[2], args[0])</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/constants"
        "ceresdb/logger"
        "ceresdb/query"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "strings"
)

func processGet(q string, tokens []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        noun := strings.ToUpper(tokens[0])
        logger.Debugf("", "processing get query with tokens %v", tokens)
        switch noun </span>{
        case constants.NOUN_COLLECTION:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 2 </span><span class="cov0" title="0">{
                        out, err := processGetCollectionAll(q, args, u)
                        return out, err
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_DATABASE:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 0 </span><span class="cov0" title="0">{
                        out, err := processGetDatabaseAll(q, args, u)
                        return out, err
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_RECORD:<span class="cov0" title="0">
                args := tokens[1:]
                logger.Tracef("", "Got record args %v with length %d", args, len(args))
                if len(args) == 2 </span><span class="cov0" title="0">{
                        return processGetRecordAll(q, args, u)
                }</span>
                <span class="cov0" title="0">if len(args) == 4 </span><span class="cov0" title="0">{
                        return processGetRecord(q, args, u)
                }</span>
                <span class="cov0" title="0">if len(args) == 6 </span><span class="cov0" title="0">{
                        logger.Tracef("", "args[3]: %s", args[3])
                        if strings.ToUpper(args[3]) == constants.ADJECTIVE_ASCENDING </span><span class="cov0" title="0">{
                                return processGetRecordAllOrderedAscending(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processGetRecordAllOrderedDescending(q, args, u)</span>
                }
                <span class="cov0" title="0">if len(args) == 8 </span><span class="cov0" title="0">{
                        if strings.ToUpper(args[5]) == constants.ADJECTIVE_ASCENDING </span><span class="cov0" title="0">{
                                return processGetRecordFilterOrderedAscending(q, args, u)
                        }</span>
                        <span class="cov0" title="0">return processGetRecordFilterOrderedDescending(q, args, u)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_SCHEMA:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 3 </span><span class="cov0" title="0">{
                        out, err := processGetSchema(q, args, u)
                        return out, err
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_USER:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return processGetUserAll(q, args, u)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("invalid query: unknown noun '%s': %s", noun, q)</span>
}

func processGetCollectionAll(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">out, err := query.ListCollections(args[1], u)
        return out, err</span>
}

func processGetDatabaseAll(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">out := query.ListDatabases(u)
        return out, nil</span>
}

func processGetRecord(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, "", constants.PREPOSITION_WHERE, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">var f map[string]interface{}
        if err := json.Unmarshal([]byte(args[3]), &amp;f); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                return query.GetRecordColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], f, u)
        }</span>
        <span class="cov0" title="0">return query.GetRecordIndex(parts[0], parts[1], f, u)</span>
}

func processGetRecordAll(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                return query.GetRecordAllColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], u)
        }</span>
        <span class="cov0" title="0">out, err := query.GetRecordAllIndex(parts[0], parts[1], u)
        return out, err</span>
}

func processGetRecordFilterOrderedAscending(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, "", constants.PREPOSITION_WHERE, "", constants.ADJECTIVE_ORDERED, constants.ADJECTIVE_ASCENDING, constants.PREPOSITION_BY, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">var f map[string]interface{}
        if err := json.Unmarshal([]byte(args[3]), &amp;f); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                objs, err := query.GetRecordColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], f, u)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys := strings.Split(args[7], ".")
                return utils.SortInterfacesAscending(keys, objs)</span>
        }
        <span class="cov0" title="0">objs, err := query.GetRecordIndex(parts[0], parts[1], f, u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">keys := strings.Split(args[7], ".")
        return utils.SortInterfacesAscending(keys, objs)</span>
}

func processGetRecordAllOrderedAscending(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, "", constants.ADJECTIVE_ORDERED, constants.ADJECTIVE_ASCENDING, constants.PREPOSITION_BY, ""}
        logger.Tracef("", "Checking all ordered ascending against %v", args)
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                logger.Tracef("", "cold storage search")
                objs, err := query.GetRecordAllColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], u)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys := strings.Split(args[5], ".")
                return utils.SortInterfacesAscending(keys, objs)</span>
        }
        <span class="cov0" title="0">logger.Tracef("", "index search")
        objs, err := query.GetRecordAllIndex(parts[0], parts[1], u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">keys := strings.Split(args[5], ".")
        return utils.SortInterfacesAscending(keys, objs)</span>
}

func processGetRecordFilterOrderedDescending(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, "", constants.PREPOSITION_WHERE, "", constants.ADJECTIVE_ORDERED, constants.ADJECTIVE_DESCENDING, constants.PREPOSITION_BY, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">var f map[string]interface{}
        if err := json.Unmarshal([]byte(args[3]), &amp;f); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                objs, err := query.GetRecordColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], f, u)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys := strings.Split(args[7], ".")
                return utils.SortInterfacesDescending(keys, objs)</span>
        }
        <span class="cov0" title="0">objs, err := query.GetRecordIndex(parts[0], parts[1], f, u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">keys := strings.Split(args[7], ".")
        return utils.SortInterfacesDescending(keys, objs)</span>
}

func processGetRecordAllOrderedDescending(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{constants.PREPOSITION_FROM, "", constants.ADJECTIVE_ORDERED, constants.ADJECTIVE_DESCENDING, constants.PREPOSITION_BY, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[1], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                objs, err := query.GetRecordAllColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], u)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">keys := strings.Split(args[5], ".")
                return utils.SortInterfacesDescending(keys, objs)</span>
        }
        <span class="cov0" title="0">objs, err := query.GetRecordAllIndex(parts[0], parts[1], u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">logger.Tracef("", "Got objects %v", objs)
        keys := strings.Split(args[5], ".")
        logger.Tracef("", "Sorting by keys %v", keys)
        return utils.SortInterfacesDescending(keys, objs)</span>
}

func processGetSchema(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_FROM, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">out, err := query.GetSchema(args[2], args[0], u)
        return out, err</span>
}

func processGetUserAll(q string, args []string, u auth.User) (interface{}, error) <span class="cov0" title="0">{
        check := []string{}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">out, err := query.GetUserAll(u)
        return out, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/constants"
        "ceresdb/query"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "strings"
)

func processInsert(q string, tokens []string, u auth.User) error <span class="cov0" title="0">{
        noun := strings.ToUpper(tokens[0])
        switch noun </span>{
        case constants.NOUN_RECORD:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 3 </span><span class="cov0" title="0">{
                        err := processInsertRecord(q, args, u)
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid query: unknown noun '%s': %s", noun, q)</span>
}

func processInsertRecord(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_INTO, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[2], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">var d interface{}
        if err := json.Unmarshal([]byte(args[0]), &amp;d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if l, ok := d.([]interface{}); ok </span><span class="cov0" title="0">{
                for _, r := range l </span><span class="cov0" title="0">{
                        if err := query.WriteRecord(parts[0], parts[1], r, u, false); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">err := query.WriteRecord(parts[0], parts[1], d, u, false)
        return err</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package aql

import (
        "ceresdb/auth"
        "ceresdb/collection"
        "ceresdb/constants"
        "ceresdb/query"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "strings"
)

func processUpdate(q string, tokens []string, u auth.User) error <span class="cov0" title="0">{
        noun := strings.ToUpper(tokens[0])
        switch noun </span>{
        case constants.NOUN_GROUP:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 6 </span><span class="cov0" title="0">{
                        err := processUpdateGroupPermission(q, args, u)
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_RECORD:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 5 </span><span class="cov0" title="0">{
                        err := processUpdateRecord(q, args, u)
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_ROLE:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 6 </span><span class="cov0" title="0">{
                        err := processUpdateRolePermission(q, args, u)
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        case constants.NOUN_USER:<span class="cov0" title="0">
                args := tokens[1:]
                if len(args) == 4 </span><span class="cov0" title="0">{
                        err := processUpdateUser(q, args, u)
                        return err
                }</span>
                <span class="cov0" title="0">if len(args) == 6 </span><span class="cov0" title="0">{
                        err := processUpdateUserPermission(q, args, u)
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid query: wrong number of arguments for %s %s statement: %s", constants.VERB_GET, noun, q)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid query: unknown noun '%s': %s", noun, q)</span>
}

func processUpdateGroupPermission(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.NOUN_PERMISSION, constants.PREPOSITION_TO, "", constants.PREPOSITION_IN, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[5], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.AddGroupAuth(parts[0], parts[1], args[0], args[3])</span>
}

func processUpdateRecord(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, "", constants.PREPOSITION_WHERE, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[0], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">var f map[string]interface{}
        if err := json.Unmarshal([]byte(args[4]), &amp;f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var d interface{}
        if err := json.Unmarshal([]byte(args[2]), &amp;d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(parts[0], constants.COLD_STORAGE_PREFIX) </span><span class="cov0" title="0">{
                return query.UpdateRecordColdStorage(parts[0][len(constants.COLD_STORAGE_PREFIX):], parts[1], f, d, u)
        }</span>
        <span class="cov0" title="0">err := query.UpdateRecordIndex(parts[0], parts[1], f, d, u)
        return err</span>
}

func processUpdateRolePermission(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.NOUN_PERMISSION, constants.PREPOSITION_TO, "", constants.PREPOSITION_IN, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[5], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.AddRoleAuth(parts[0], parts[1], args[0], args[3])</span>
}

func processUpdateUser(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.PREPOSITION_WITH, constants.NOUN_PASSWORD, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(constants.AUTH_DB_NAME, constants.AUTH_COLLECTION_NAME, constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return query.UpdateUserPassword(args[0], args[3], u)</span>
}

func processUpdateUserPermission(q string, args []string, u auth.User) error <span class="cov0" title="0">{
        check := []string{"", constants.NOUN_PERMISSION, constants.PREPOSITION_TO, "", constants.PREPOSITION_IN, ""}
        if !utils.CompareSlicePattern(args, check) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: syntax error: %s", q)
        }</span>
        <span class="cov0" title="0">parts := strings.Split(args[5], ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid query: invalid resource specification: %s", q)
        }</span>
        <span class="cov0" title="0">if err := collection.VerifyAuth(parts[0], parts[1], constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return collection.AddUserAuth(parts[0], parts[1], args[0], args[3])</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "ceresdb/constants"
        "ceresdb/utils"
        "fmt"
        "log"

        "golang.org/x/crypto/bcrypt"
)

type User struct {
        Username string   `json:"username"`
        Password string   `json:"password"`
        Roles    []string `json:"roles"`
        Groups   []string `json:"groups"`
}

var Users map[string]User

var permissionList = []string{constants.PERMISSION_ADMIN, constants.PERMISSION_UPDATE, constants.PERMISSION_WRITE, constants.PERMISSION_READ}

func CheckPermissions(a, b string) error <span class="cov8" title="1">{
        // b is guaranteed to be one of the above constants, so we don't need to check for -1
        idx := utils.Index(permissionList, b)
        jdx := utils.Index(permissionList, a)
        for _, val := range permissionList[:jdx+1] </span><span class="cov8" title="1">{
                if b == val </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("permission %s is at a higher index (%d) than desired permission %s (%d)", b, idx, a, jdx)</span>
}

func ComparePasswords(hashedPassword string, plainPassword string) bool <span class="cov8" title="1">{
        // Since we'll be getting the hashed password from the DB it
        // will be a string so we'll need to convert it to a byte slice
        byteHash := []byte(hashedPassword)
        bytePlain := []byte(plainPassword)
        err := bcrypt.CompareHashAndPassword(byteHash, bytePlain)
        if err != nil </span><span class="cov8" title="1">{
                log.Println(err)
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package collection

import (
        "ceresdb/auth"
        "ceresdb/config"
        "ceresdb/constants"
        "ceresdb/index"
        "ceresdb/logger"
        "ceresdb/schema"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
)

type File struct {
        Length    int   `json:"length" yaml:"length"`
        Available []int `json:"available" yaml:"available"`
}

type Collection struct {
        Files  map[string]File   `json:"files" yaml:"files"`
        Users  map[string]string `json:"users" yaml:"users"`
        Groups map[string]string `json:"groups" yaml:"group"`
        Roles  map[string]string `json:"roles" yaml:"roles"`
}

var Collections map[string]map[string]Collection

func LoadCollections() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/collections.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                Collections = make(map[string]map[string]Collection)
                return nil
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(byteValue, &amp;Collections)
        return nil</span>
}

func Create(d, name string) error <span class="cov8" title="1">{
        if Collections == nil </span><span class="cov0" title="0">{
                Collections = make(map[string]map[string]Collection)
        }</span>
        <span class="cov8" title="1">if _, ok := Collections[d]; !ok </span><span class="cov8" title="1">{
                Collections[d] = map[string]Collection{}
        }</span>
        <span class="cov8" title="1">c := Collection{
                Files: make(map[string]File),
                Users: map[string]string{
                        config.Config.AdminUsername: constants.PERMISSION_ADMIN,
                },
                Groups: map[string]string{
                        constants.GROUP_ADMIN: constants.PERMISSION_ADMIN,
                },
                Roles: map[string]string{
                        constants.ROLE_ADMIN: constants.ROLE_ADMIN,
                },
        }
        Collections[d][name] = c

        return saveCollections()</span>
}

func Delete(d, name string) error <span class="cov8" title="1">{
        if err := index.Delete(d, name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := schema.Delete(d, name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for f, _ := range Collections[d][name].Files </span><span class="cov0" title="0">{
                path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, name, f)
                if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">delete(Collections[d], name)
        return saveCollections()</span>
}

func updateAuth(d, name string, us, gs, rs map[string]string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        c.Users = us
        c.Groups = gs
        c.Roles = rs
        Collections[d][name] = c
        return saveCollections()
}</span>

func AddGroupAuth(d, name, g, p string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        us := c.Users
        gs := c.Groups
        rs := c.Roles
        gs[g] = p
        return updateAuth(d, name, us, gs, rs)
}</span>

func DeleteGroupAuth(d, name, g string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        us := c.Users
        gs := c.Groups
        rs := c.Roles
        if _, ok := gs[g]; ok </span><span class="cov8" title="1">{
                delete(gs, g)
        }</span>
        <span class="cov8" title="1">return updateAuth(d, name, us, gs, rs)</span>
}

func AddRoleAuth(d, name, r, p string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        us := c.Users
        gs := c.Groups
        rs := c.Roles
        rs[r] = p
        return updateAuth(d, name, us, gs, rs)
}</span>

func DeleteRoleAuth(d, name, r string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        us := c.Users
        gs := c.Groups
        rs := c.Roles
        if _, ok := rs[r]; ok </span><span class="cov8" title="1">{
                delete(rs, r)
        }</span>
        <span class="cov8" title="1">return updateAuth(d, name, us, gs, rs)</span>
}

func AddUserAuth(d, name, u, p string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        us := c.Users
        gs := c.Groups
        rs := c.Roles
        us[u] = p
        return updateAuth(d, name, us, gs, rs)
}</span>

func DeleteUserAuth(d, name, u string) error <span class="cov8" title="1">{
        c := Collections[d][name]
        us := c.Users
        gs := c.Groups
        rs := c.Roles
        if _, ok := us[u]; ok </span><span class="cov8" title="1">{
                delete(us, u)
        }</span>
        <span class="cov8" title="1">return updateAuth(d, name, us, gs, rs)</span>
}

func VerifyAuth(d, c, p string, u auth.User) error <span class="cov8" title="1">{
        col := Collections[d][c]
        for name, permission := range col.Users </span><span class="cov8" title="1">{
                logger.Tracef("", "Checking collection user auth against %s | %s", name, u.Username)
                if name == u.Username </span><span class="cov8" title="1">{
                        // if err := auth.CheckPermissions(p, permission); err == nil {
                        //         return fmt.Errorf("Found success in user with permission %s", permission)
                        // }
                        return auth.CheckPermissions(p, permission)
                }</span>
        }
        <span class="cov8" title="1">for name, permission := range col.Groups </span><span class="cov8" title="1">{
                for _, g := range u.Groups </span><span class="cov8" title="1">{
                        logger.Tracef("", "Checking collection group auth %s | %s", name, g)
                        if name == g </span><span class="cov8" title="1">{
                                // if err := auth.CheckPermissions(p, permission); err == nil {
                                //         return fmt.Errorf("Found success in group with permission %s", permission)
                                // }
                                return auth.CheckPermissions(p, permission)
                        }</span>
                }
        }
        <span class="cov8" title="1">for name, permission := range col.Roles </span><span class="cov8" title="1">{
                for _, r := range u.Roles </span><span class="cov8" title="1">{
                        logger.Tracef("", "Checking collection role auth %s | %s", name, r)
                        if name == r </span><span class="cov8" title="1">{
                                // if err := auth.CheckPermissions(p, permission); err == nil {
                                //         return fmt.Errorf("Found success in role with permission %s", permission)
                                // }
                                return auth.CheckPermissions(p, permission)
                        }</span>
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("user %s does not have access to %s.%s", u.Username, d, c)</span>
}

func saveCollections() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/collections.json", config.Config.DataDir)
        data, err := json.Marshal(Collections)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0777)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// config.go

package config

import (
        "ceresdb/logger"
        "encoding/json"
        "io/ioutil"
        "log"
        "os"
        "os/user"
        "path/filepath"
        "reflect"
        "strconv"
        "strings"
)

const DEFAULT_CONFIG_PATH = ".ceresdb/config/config.json"
const ENV_PREFIX = "CERESDB_"

type ConfigObject struct {
        LogLevel         string `json:"log_level" env:"LOG_LEVEL"`
        LogFormat        string `json:"log_format" env:"LOG_FORMAT"`
        DataDir          string `json:"data_dir" env:"DATA_DIR"`
        StorageLineLimit int    `json:"storage_line_limit" env:"STORAGE_LINE_LIMIT"`
        Port             int    `json:"port" env:"PORT"`
        AdminUsername    string `json:"admin_username" env:"ADMIN_USERNAME"`
        AdminPassword    string `json:"admin_password" env:"ADMIN_PASSWORD"`
        MaxIndexSize     int    `json:"max_index_size" env:"MAX_INDEX_SIZE"`
}

var Config ConfigObject

func ReadConfig() <span class="cov8" title="1">{
        configPath := os.Getenv(ENV_PREFIX + "CONFIG_PATH")
        if configPath == "" </span><span class="cov8" title="1">{
                configPath = DEFAULT_CONFIG_PATH
        }</span>

        <span class="cov8" title="1">Config = ConfigObject{
                LogLevel:         logger.LOG_LEVEL_INFO,
                LogFormat:        logger.LOG_FORMAT_CONSOLE,
                DataDir:          "/tmp/ceresdb",
                StorageLineLimit: 1000,
                Port:             7437,
                AdminUsername:    "ceresdb",
                AdminPassword:    "ceresdb",
                MaxIndexSize:     1000,
        }

        jsonFile, err := os.Open(configPath)
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("Successfully Opened %v", configPath)

                byteValue, _ := ioutil.ReadAll(jsonFile)

                json.Unmarshal(byteValue, &amp;Config)
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(Config)
        t := reflect.TypeOf(Config)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                field, found := t.FieldByName(v.Type().Field(i).Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">value := field.Tag.Get("env")
                if value != "" </span><span class="cov8" title="1">{
                        val, present := os.LookupEnv(ENV_PREFIX + value)
                        if present </span><span class="cov8" title="1">{
                                // log.Printf("Found ENV var %s with value %s", ENV_PREFIX+value, val)
                                w := reflect.ValueOf(&amp;Config).Elem().FieldByName(t.Field(i).Name)
                                x := getAttr(&amp;Config, t.Field(i).Name).Kind().String()
                                if w.IsValid() </span><span class="cov8" title="1">{
                                        switch x </span>{
                                        case "int", "int64":<span class="cov8" title="1">
                                                i, err := strconv.ParseInt(val, 10, 64)
                                                if err == nil </span><span class="cov8" title="1">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int8":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 8)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int16":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 16)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int32":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 32)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "string":<span class="cov8" title="1">
                                                w.SetString(val)</span>
                                        case "float32":<span class="cov0" title="0">
                                                i, err := strconv.ParseFloat(val, 32)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetFloat(i)
                                                }</span>
                                        case "float", "float64":<span class="cov0" title="0">
                                                i, err := strconv.ParseFloat(val, 64)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetFloat(i)
                                                }</span>
                                        case "bool":<span class="cov0" title="0">
                                                i, err := strconv.ParseBool(val)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetBool(i)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                objValue := reflect.New(field.Type)
                                                objInterface := objValue.Interface()
                                                err := json.Unmarshal([]byte(val), objInterface)
                                                obj := reflect.ValueOf(objInterface)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.Set(reflect.Indirect(obj).Convert(field.Type))
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Println(err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // defer the closing of our jsonFile so that we can parse it later on
        <span class="cov8" title="1">defer jsonFile.Close()

        usr, _ := user.Current()
        dir := usr.HomeDir

        // Expand home directory
        if Config.DataDir == "~" </span><span class="cov0" title="0">{
                Config.DataDir = dir
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(Config.DataDir, "~/") </span><span class="cov0" title="0">{
                Config.DataDir = filepath.Join(dir, Config.DataDir[2:])
        }</span>
}

func getAttr(obj interface{}, fieldName string) reflect.Value <span class="cov8" title="1">{
        pointToStruct := reflect.ValueOf(obj) // addressable
        curStruct := pointToStruct.Elem()
        if curStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                panic("not struct")</span>
        }
        <span class="cov8" title="1">curField := curStruct.FieldByName(fieldName) // type: reflect.Value
        if !curField.IsValid() </span><span class="cov0" title="0">{
                panic("not found:" + fieldName)</span>
        }
        <span class="cov8" title="1">return curField</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "ceresdb/auth"
        "ceresdb/config"
        "ceresdb/constants"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
)

type Database struct {
        Collections []string          `json:"collections" yaml:"collections"`
        Users       map[string]string `json:"users" yaml:"users"`
        Groups      map[string]string `json:"groups" yaml:"group"`
        Roles       map[string]string `json:"roles" yaml:"roles"`
}

var Databases map[string]Database

func LoadDatabases() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/databases.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                Databases = make(map[string]Database)
                return nil
        }</span>

        <span class="cov8" title="1">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">json.Unmarshal(byteValue, &amp;Databases)
        return nil</span>
}

func Create(name string) error <span class="cov8" title="1">{
        d := Database{
                Collections: []string{},
                Users: map[string]string{
                        config.Config.AdminUsername: constants.PERMISSION_ADMIN,
                },
                Groups: map[string]string{
                        constants.GROUP_ADMIN: constants.PERMISSION_ADMIN,
                },
                Roles: map[string]string{
                        constants.ROLE_ADMIN: constants.ROLE_ADMIN,
                },
        }
        if Databases == nil </span><span class="cov0" title="0">{
                Databases = make(map[string]Database)
        }</span>
        <span class="cov8" title="1">Databases[name] = d
        path := fmt.Sprintf("%s/databases.json", config.Config.DataDir)
        data, err := json.Marshal(Databases)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0777)</span>
}

func Delete(name string) error <span class="cov8" title="1">{
        delete(Databases, name)
        path := fmt.Sprintf("%s/databases.json", config.Config.DataDir)
        data, err := json.Marshal(Databases)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0777)</span>
}

func AddCollection(d, name string, u auth.User) error <span class="cov0" title="0">{
        if err := VerifyAuth(d, constants.PERMISSION_WRITE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">db := Databases[d]
        db.Collections = append(db.Collections, name)
        Databases[d] = db
        return saveDatabases()</span>
}

func DeleteCollection(d, name string, u auth.User) error <span class="cov0" title="0">{
        if err := VerifyAuth(d, constants.PERMISSION_UPDATE, u); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">db := Databases[d]
        db.Collections = utils.Remove(db.Collections, name)
        Databases[d] = db
        return saveDatabases()</span>
}

func updateAuth(name string, us, gs, rs map[string]string) error <span class="cov8" title="1">{
        d := Databases[name]
        d.Users = us
        d.Groups = gs
        d.Roles = rs
        Databases[name] = d
        return saveDatabases()
}</span>

func AddGroupAuth(name, g, p string) error <span class="cov8" title="1">{
        d := Databases[name]
        us := d.Users
        gs := d.Groups
        rs := d.Roles
        gs[g] = p
        return updateAuth(name, us, gs, rs)
}</span>

func DeleteGroupAuth(name, g string) error <span class="cov8" title="1">{
        d := Databases[name]
        us := d.Users
        gs := d.Groups
        rs := d.Roles
        if _, ok := gs[g]; ok </span><span class="cov8" title="1">{
                delete(gs, g)
        }</span>
        <span class="cov8" title="1">return updateAuth(name, us, gs, rs)</span>
}

func AddRoleAuth(name, r, p string) error <span class="cov8" title="1">{
        d := Databases[name]
        us := d.Users
        gs := d.Groups
        rs := d.Roles
        rs[r] = p
        return updateAuth(name, us, gs, rs)
}</span>

func DeleteRoleAuth(name, r string) error <span class="cov8" title="1">{
        d := Databases[name]
        us := d.Users
        gs := d.Groups
        rs := d.Roles
        if _, ok := rs[r]; ok </span><span class="cov8" title="1">{
                delete(rs, r)
        }</span>
        <span class="cov8" title="1">return updateAuth(name, us, gs, rs)</span>
}

func AddUserAuth(name, u, p string) error <span class="cov8" title="1">{
        d := Databases[name]
        us := d.Users
        gs := d.Groups
        rs := d.Roles
        us[u] = p
        return updateAuth(name, us, gs, rs)
}</span>

func DeleteUserAuth(name, u string) error <span class="cov8" title="1">{
        d := Databases[name]
        us := d.Users
        gs := d.Groups
        rs := d.Roles
        if _, ok := us[u]; ok </span><span class="cov8" title="1">{
                delete(us, u)
        }</span>
        <span class="cov8" title="1">return updateAuth(name, us, gs, rs)</span>
}

func VerifyAuth(name, p string, u auth.User) error <span class="cov8" title="1">{
        d := Databases[name]
        for name, permission := range d.Users </span><span class="cov8" title="1">{
                if name == u.Username </span><span class="cov8" title="1">{
                        return auth.CheckPermissions(p, permission)
                }</span>
        }
        <span class="cov8" title="1">for name, permission := range d.Groups </span><span class="cov8" title="1">{
                for _, g := range u.Groups </span><span class="cov8" title="1">{
                        if name == g </span><span class="cov8" title="1">{
                                return auth.CheckPermissions(p, permission)
                        }</span>
                }
        }
        <span class="cov8" title="1">for name, permission := range d.Roles </span><span class="cov8" title="1">{
                for _, r := range u.Roles </span><span class="cov8" title="1">{
                        if name == r </span><span class="cov8" title="1">{
                                return auth.CheckPermissions(p, permission)
                        }</span>
                }
        }
        <span class="cov0" title="0">return fmt.Errorf("user %s does not have access to %s", u.Username, name)</span>
}

func saveDatabases() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/databases.json", config.Config.DataDir)
        data, err := json.Marshal(Databases)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0777)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package index

import (
        "ceresdb/config"
        "ceresdb/constants"
        "ceresdb/schema"
        "ceresdb/utils"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "strings"
)

const STRING_TERM = "//x00"

//                db         col        var
var Indices map[string]map[string]interface{}
var IndexKeys map[string]map[string][]string
var IndexIDs map[string]map[string][]string
var IndexCache map[string]map[string][]interface{}

const STRING_SPLIT_CHAR = " "

func LoadIndices() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/indices.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                Indices = make(map[string]map[string]interface{})
                return nil
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(byteValue, &amp;Indices)
        return nil</span>
}

func LoadIndexKeys() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/index_keys.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                IndexKeys = make(map[string]map[string][]string)
                return nil
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(byteValue, &amp;IndexKeys)
        return nil</span>
}

func LoadIndexIDs() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/index_ids.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                IndexIDs = make(map[string]map[string][]string)
                return nil
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(byteValue, &amp;IndexIDs)
        return nil</span>
}

func LoadIndexCache() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/index_cache.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                IndexCache = make(map[string]map[string][]interface{})
                return nil
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(byteValue, &amp;IndexIDs)
        return nil</span>
}

func Delete(d, c string) error <span class="cov8" title="1">{
        delete(Indices[d], c)
        delete(IndexKeys[d], c)
        delete(IndexIDs[d], c)
        delete(IndexCache[d], c)
        return saveIndices()
}</span>

func BuildIndex(d, c string) error <span class="cov8" title="1">{
        s := schema.Schemas[d][c]
        if Indices == nil </span><span class="cov0" title="0">{
                Indices = map[string]map[string]interface{}{}
                IndexKeys = map[string]map[string][]string{}
                IndexIDs = map[string]map[string][]string{}
                IndexCache = map[string]map[string][]interface{}{}
        }</span>
        <span class="cov8" title="1">if _, ok := Indices[d]; !ok </span><span class="cov8" title="1">{
                Indices[d] = map[string]interface{}{}
                IndexKeys[d] = map[string][]string{}
                IndexIDs[d] = map[string][]string{}
                IndexCache[d] = map[string][]interface{}{}
        }</span>
        <span class="cov8" title="1">keys := []string{}
        var idx interface{}
        idx, keys = buildIndexAgainstSchema(s, keys, "")
        Indices[d][c] = idx
        IndexKeys[d][c] = keys
        IndexIDs[d][c] = []string{}
        IndexCache[d][c] = []interface{}{}
        return saveIndices()</span>
}

// This functino assumes that the schema has already been verified
func buildIndexAgainstSchema(s interface{}, keys []string, key string) (interface{}, []string) <span class="cov8" title="1">{
        if typeName, ok := s.(string); ok </span><span class="cov8" title="1">{
                switch typeName </span>{
                case constants.DATATYPE_STRING:<span class="cov8" title="1">
                        return map[string][]string{}, keys</span>
                case constants.DATATYPE_INT:<span class="cov8" title="1">
                        return map[int][]string{}, keys</span>
                case constants.DATATYPE_FLOAT:<span class="cov8" title="1">
                        return map[float64][]string{}, keys</span>
                case constants.DATATYPE_BOOL:<span class="cov8" title="1">
                        return map[bool][]string{}, keys</span>
                }
                <span class="cov0" title="0">return nil, keys</span>
        }

        <span class="cov8" title="1">if dict, ok := s.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if len(dict) == 0 </span><span class="cov0" title="0">{
                        return nil, keys
                }</span>
                <span class="cov8" title="1">out := map[string]interface{}{}
                for child, val := range dict </span><span class="cov8" title="1">{
                        var o interface{}
                        o, keys = buildIndexAgainstSchema(val, keys, fmt.Sprintf("%s.%s", key, child))
                        if o != nil </span><span class="cov8" title="1">{
                                keys = append(keys, fmt.Sprintf("%s.%s", key, child))
                        }</span>
                        <span class="cov8" title="1">out[child] = o</span>
                }
                <span class="cov8" title="1">return out, keys</span>
        }

        <span class="cov8" title="1">list := s.([]interface{})
        if val, ok := list[0].(interface{}); ok </span><span class="cov8" title="1">{
                var o interface{}
                o, keys = buildIndexAgainstSchema(val, keys, key)
                if o != nil </span><span class="cov8" title="1">{
                        keys = append(keys, key)
                }</span>
                <span class="cov8" title="1">return o, keys</span>
        }
        <span class="cov0" title="0">return nil, keys</span>
}

func AddToIndex(d, c string, obj interface{}) error <span class="cov8" title="1">{
        s := schema.Schemas[d][c]
        objInterface := obj.(map[string]interface{})
        id := objInterface["_id"].(string)
        Indices[d][c] = addAgainstIndex(id, Indices[d][c], s, obj)
        IndexIDs[d][c] = append(IndexIDs[d][c], id)
        IndexCache[d][c] = append(IndexCache[d][c], obj)
        if len(IndexIDs) &gt; config.Config.MaxIndexSize </span><span class="cov0" title="0">{
                DeleteFromIndex(d, c, IndexCache[d][c][0])
        }</span>
        <span class="cov8" title="1">return saveIndices()</span>
}

func addAgainstIndex(id string, idx, s, obj interface{}) interface{} <span class="cov8" title="1">{
        if idx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if typeName, ok := s.(string); ok </span><span class="cov8" title="1">{
                switch typeName </span>{
                case constants.DATATYPE_STRING:<span class="cov8" title="1">
                        idxInterface := idx.(map[string][]string)
                        key := obj.(string)
                        temp := []string{}
                        if val, ok := idxInterface[key]; ok </span><span class="cov0" title="0">{
                                temp = val
                        }</span>
                        <span class="cov8" title="1">temp = append(temp, id)
                        idxInterface[key] = temp
                        idx = idxInterface</span>
                case constants.DATATYPE_INT:<span class="cov8" title="1">
                        idxInterface := idx.(map[int][]string)
                        key := 0
                        if val, ok := obj.(int); ok </span><span class="cov8" title="1">{
                                key = val
                        }</span> else<span class="cov0" title="0"> {
                                key = int(obj.(float64))
                        }</span>
                        <span class="cov8" title="1">temp := []string{}
                        if val, ok := idxInterface[key]; ok </span><span class="cov0" title="0">{
                                temp = val
                        }</span>
                        <span class="cov8" title="1">temp = append(temp, id)
                        idxInterface[key] = temp
                        idx = idxInterface</span>
                case constants.DATATYPE_FLOAT:<span class="cov8" title="1">
                        idxInterface := idx.(map[float64][]string)
                        key := obj.(float64)
                        temp := []string{}
                        if val, ok := idxInterface[key]; ok </span><span class="cov0" title="0">{
                                temp = val
                        }</span>
                        <span class="cov8" title="1">temp = append(temp, id)
                        idxInterface[key] = temp
                        idx = idxInterface</span>
                case constants.DATATYPE_BOOL:<span class="cov8" title="1">
                        idxInterface := idx.(map[bool][]string)
                        key := obj.(bool)
                        temp := []string{}
                        if val, ok := idxInterface[key]; ok </span><span class="cov0" title="0">{
                                temp = val
                        }</span>
                        <span class="cov8" title="1">temp = append(temp, id)
                        idxInterface[key] = temp
                        idx = idxInterface</span>
                }
                <span class="cov8" title="1">return idx</span>
        }
        <span class="cov8" title="1">if dict, ok := obj.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                idxInterface := idx.(map[string]interface{})
                sInterface := s.(map[string]interface{})
                for key, child := range dict </span><span class="cov8" title="1">{
                        if key == constants.ID_KEY </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">i := addAgainstIndex(id, idxInterface[key], sInterface[key], child)
                        idxInterface[key] = i</span>
                }
                <span class="cov8" title="1">return idxInterface</span>
        }
        <span class="cov8" title="1">list := obj.([]interface{})
        for _, val := range list </span><span class="cov8" title="1">{
                sInterface := s.([]interface{})
                idx = addAgainstIndex(id, idx, sInterface[0], val)
        }</span>
        <span class="cov8" title="1">return idx</span>
}

func DeleteFromIndex(d, c string, obj interface{}) error <span class="cov8" title="1">{
        s := schema.Schemas[d][c]
        objInterface := obj.(map[string]interface{})
        id := objInterface["_id"].(string)
        Indices[d][c] = deleteAgainstIndex(id, Indices[d][c], s, obj)
        cacheIdx := utils.Index(IndexIDs[d][c], id)
        IndexIDs[d][c] = append(IndexIDs[d][c][:cacheIdx], IndexIDs[d][c][cacheIdx+1:]...)
        IndexCache[d][c] = append(IndexCache[d][c][:cacheIdx], IndexCache[d][c][cacheIdx+1:]...)
        // IndexIDs[d][c] = utils.Remove(IndexIDs[d][c], id)
        // IndexCache[d][c] = utils.Remove(IndexIDs[d][c], obj)
        return saveIndices()
}</span>

func deleteAgainstIndex(id string, idx, s, obj interface{}) interface{} <span class="cov8" title="1">{
        if idx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if typeName, ok := s.(string); ok </span><span class="cov8" title="1">{
                switch typeName </span>{
                case constants.DATATYPE_STRING:<span class="cov8" title="1">
                        idxInterface := idx.(map[string][]string)
                        key := obj.(string)
                        idxInterface[key] = utils.Remove(idxInterface[key], id)
                        return idxInterface</span>
                case constants.DATATYPE_INT:<span class="cov8" title="1">
                        idxInterface := idx.(map[int][]string)
                        key := 0
                        if val, ok := obj.(int); ok </span><span class="cov8" title="1">{
                                key = val
                        }</span> else<span class="cov0" title="0"> {
                                key = int(obj.(float64))
                        }</span>
                        <span class="cov8" title="1">idxInterface[key] = utils.Remove(idxInterface[key], id)
                        return idxInterface</span>
                case constants.DATATYPE_FLOAT:<span class="cov8" title="1">
                        idxInterface := idx.(map[float64][]string)
                        key := obj.(float64)
                        idxInterface[key] = utils.Remove(idxInterface[key], id)
                        return idxInterface</span>
                case constants.DATATYPE_BOOL:<span class="cov8" title="1">
                        idxInterface := idx.(map[bool][]string)
                        key := obj.(bool)
                        idxInterface[key] = utils.Remove(idxInterface[key], id)
                        return idxInterface</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov8" title="1">if dict, ok := obj.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                idxInterface := idx.(map[string]interface{})
                sInterface := s.(map[string]interface{})
                for key, child := range dict </span><span class="cov8" title="1">{
                        if key == constants.ID_KEY </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">idxInterface[key] = deleteAgainstIndex(id, idxInterface[key], sInterface[key], child)</span>
                }
                <span class="cov8" title="1">return idxInterface</span>
        }
        <span class="cov8" title="1">list := obj.([]interface{})
        for _, val := range list </span><span class="cov8" title="1">{
                sInterface := s.([]interface{})
                idx = deleteAgainstIndex(id, idx, sInterface[0], val)
        }</span>
        <span class="cov8" title="1">return idx</span>
}

func RetrieveFromIndex(d, c string, keys []string, val interface{}) ([]string, error) <span class="cov8" title="1">{
        s := schema.Schemas[d][c]
        idx := Indices[d][c]
        keyString := "." + strings.Join(keys, ".")
        if !utils.Contains(IndexKeys[d][c], keyString) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key %s is not searchable in %s.%s: %v", keyString, d, c, IndexKeys[d][c])
        }</span>
        <span class="cov8" title="1">out := retrieveAgainstIndex(keys, idx, s, val)
        return out, nil</span>
}

func retrieveAgainstIndex(keys []string, idx, s, val interface{}) []string <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov8" title="1">{
                typeName := s.(string)
                switch typeName </span>{
                case constants.DATATYPE_STRING:<span class="cov8" title="1">
                        idxInterface := idx.(map[string][]string)
                        value := val.(string)
                        outInterface := idxInterface[value]
                        out := outInterface
                        return out</span>
                case constants.DATATYPE_INT:<span class="cov0" title="0">
                        idxInterface := idx.(map[int][]string)
                        value := 0
                        if v, ok := val.(int); ok </span><span class="cov0" title="0">{
                                value = v
                        }</span> else<span class="cov0" title="0"> {
                                value = int(val.(float64))
                        }</span>

                        <span class="cov0" title="0">outInterface := idxInterface[value]
                        out := outInterface
                        return out</span>
                case constants.DATATYPE_FLOAT:<span class="cov0" title="0">
                        idxInterface := idx.(map[float64][]string)
                        value := val.(float64)
                        outInterface := idxInterface[value]
                        out := outInterface
                        return out</span>
                case constants.DATATYPE_BOOL:<span class="cov0" title="0">
                        idxInterface := idx.(map[bool][]string)
                        value := val.(bool)
                        outInterface := idxInterface[value]
                        out := outInterface
                        return out</span>
                }
                <span class="cov0" title="0">return []string{}</span>
        }
        <span class="cov8" title="1">idxInterface := idx.(map[string]interface{})
        sInterface := s.(map[string]interface{})
        out := retrieveAgainstIndex(keys[1:], idxInterface[keys[0]], sInterface[keys[0]], val)
        return out</span>
}

func RetrieveValsFromIndex(d, c string, keys []string) (string, interface{}, error) <span class="cov8" title="1">{
        s := schema.Schemas[d][c]
        idx := Indices[d][c]
        keyString := "." + strings.Join(keys, ".")
        if !utils.Contains(IndexKeys[d][c], keyString) </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("key %s is not searchable in %s.%s: %v", keyString, d, c, IndexKeys[d][c])
        }</span>
        <span class="cov8" title="1">dType, out := retrieveValsAgainstIndex(keys, idx, s)
        return dType, out, nil</span>
}

func retrieveValsAgainstIndex(keys []string, idx, s interface{}) (string, interface{}) <span class="cov8" title="1">{
        if len(keys) == 0 </span><span class="cov8" title="1">{
                typeName := s.(string)
                switch typeName </span>{
                case constants.DATATYPE_STRING:<span class="cov8" title="1">
                        out := idx.(map[string][]string)
                        return typeName, out</span>
                case constants.DATATYPE_INT:<span class="cov0" title="0">
                        out := idx.(map[int][]string)
                        return typeName, out</span>
                case constants.DATATYPE_FLOAT:<span class="cov0" title="0">
                        out := idx.(map[float64][]string)
                        return typeName, out</span>
                case constants.DATATYPE_BOOL:<span class="cov0" title="0">
                        out := idx.(map[bool][]string)
                        return typeName, out</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("type %s is not valid", typeName), nil</span>
                // return typeName, nil
        }
        <span class="cov8" title="1">idxInterface := idx.(map[string]interface{})
        sInterface := s.(map[string]interface{})
        dType, out := retrieveValsAgainstIndex(keys[1:], idxInterface[keys[0]], sInterface[keys[0]])
        return dType, out</span>
}

func saveIndices() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/indices.json", config.Config.DataDir)
        data, err := json.Marshal(Indices)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0777); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">path2 := fmt.Sprintf("%s/index_keys.json", config.Config.DataDir)
        data2, err := json.Marshal(IndexKeys)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path2, data2, 0777); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">path3 := fmt.Sprintf("%s/indices.json", config.Config.DataDir)
        data3, err := json.Marshal(IndexKeys)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path3, data3, 0777); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">path4 := fmt.Sprintf("%s/index_cache.json", config.Config.DataDir)
        data4, err := json.Marshal(IndexKeys)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path4, data4, 0777); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package record

import (
        "ceresdb/collection"
        "ceresdb/config"
        "ceresdb/constants"
        "ceresdb/index"
        "ceresdb/logger"
        "ceresdb/schema"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "strconv"
        "strings"

        "github.com/google/uuid"
)

func Delete(d, c, id string) error <span class="cov8" title="1">{
        err := doDelete(d, c, id)
        return err
}</span>

func Get(d, c, id string) (interface{}, error) <span class="cov8" title="1">{
        out, err := doRead(d, c, id)
        return out, err
}</span>

func GetAllIndex(d, c string) ([]interface{}, error) <span class="cov8" title="1">{
        output := []interface{}{}
        logger.Debugf("", "Searching through index IDs")
        for _, id := range index.IndexIDs[d][c] </span><span class="cov8" title="1">{
                logger.Tracef("", "got id %s id", id)
                r, err := Get(d, c, id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">output = append(output, r)</span>
        }
        <span class="cov8" title="1">return output, nil</span>
}

func GetAllColdStorage(d, c string) ([]interface{}, error) <span class="cov0" title="0">{
        output := []interface{}{}
        for f, fi := range collection.Collections[d][c].Files </span><span class="cov0" title="0">{
                if fi.Length &gt; 0 </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, c, f)
                        lines, err := ReadDataFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">for _, line := range lines </span><span class="cov0" title="0">{
                                if len(line) &gt; 0 </span><span class="cov0" title="0">{
                                        var val interface{}
                                        if err := json.Unmarshal([]byte(line), &amp;val); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">output = append(output, val)</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return output, nil</span>
}

func Update(d, c, id string, data interface{}) error <span class="cov8" title="1">{
        if err := schema.ValidateSchema(d, c, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">temp := data.(map[string]interface{})
        temp[constants.ID_KEY] = id
        return doUpdate(d, c, id, temp)</span>
}

func Write(d, c string, data interface{}) error <span class="cov8" title="1">{
        if err := schema.ValidateSchema(d, c, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">temp := data.(map[string]interface{})
        err := doWrite(d, c, temp)
        return err</span>
}

func doDelete(d, c, id string) error <span class="cov8" title="1">{
        parts := strings.Split(id, ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid ID, must be of format &lt;uuid&gt;.&lt;int&gt;")
        }</span>
        <span class="cov8" title="1">path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, c, parts[0])
        idx, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid ID, must be of format &lt;uuid&gt;.&lt;int&gt;")
        }</span>
        <span class="cov8" title="1">lines, err := ReadDataFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if idx &gt; len(lines) </span><span class="cov0" title="0">{
                return fmt.Errorf("Record with ID %s does not exist", id)
        }</span>
        <span class="cov8" title="1">if lines[idx] == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Record with ID %s does not exist", id)
        }</span>
        <span class="cov8" title="1">temp := lines[idx]
        lines[idx] = ""

        fi := collection.Collections[d][c].Files[parts[0]]
        col := collection.Collections[d][c]
        col.Files[parts[0]] = fi
        fi.Length -= 1
        fi.Available[idx] = 0
        collection.Collections[d][c] = col
        cPath := fmt.Sprintf("%s/collections.json", config.Config.DataDir)
        data, err := json.Marshal(collection.Collections)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(cPath, data, 0777); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var val interface{}
        if err := json.Unmarshal([]byte(temp), &amp;val); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">index.DeleteFromIndex(d, c, val)

        return writeDataFile(path, lines)</span>
}

func doRead(d, c, id string) (interface{}, error) <span class="cov8" title="1">{
        parts := strings.Split(id, ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Invalid ID, must be of format &lt;uuid&gt;.&lt;int&gt;")
        }</span>
        <span class="cov8" title="1">path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, c, parts[0])
        idx, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Invalid ID, must be of format &lt;uuid&gt;.&lt;int&gt;")
        }</span>
        <span class="cov8" title="1">lines, err := ReadDataFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if idx &gt; len(lines) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Record with ID %s does not exist", id)
        }</span>
        <span class="cov8" title="1">if lines[idx] == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Record with ID %s does not exist", id)
        }</span>

        <span class="cov8" title="1">var val interface{}
        if err := json.Unmarshal([]byte(lines[idx]), &amp;val); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func doUpdate(d, c, id string, val interface{}) error <span class="cov8" title="1">{
        parts := strings.Split(id, ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid ID, must be of format &lt;uuid&gt;.&lt;int&gt;")
        }</span>
        <span class="cov8" title="1">path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, c, parts[0])
        idx, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid ID, must be of format &lt;uuid&gt;.&lt;int&gt;")
        }</span>
        <span class="cov8" title="1">lines, err := ReadDataFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if idx &gt; len(lines) </span><span class="cov0" title="0">{
                return fmt.Errorf("Record with ID %s does not exist", id)
        }</span>
        <span class="cov8" title="1">if lines[idx] == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Record with ID %s does not exist", id)
        }</span>

        <span class="cov8" title="1">new := val.(map[string]interface{})
        var current map[string]interface{}
        if err := json.Unmarshal([]byte(lines[idx]), &amp;current); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for key, val := range new </span><span class="cov8" title="1">{
                current[key] = val
        }</span>
        <span class="cov8" title="1">data, err := json.Marshal(current)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lines[idx] = string(data)

        index.DeleteFromIndex(d, c, val)
        index.AddToIndex(d, c, current)

        return writeDataFile(path, lines)</span>
}

func doWrite(d, c string, datum map[string]interface{}) error <span class="cov8" title="1">{

        for f, fi := range collection.Collections[d][c].Files </span><span class="cov0" title="0">{
                if fi.Length &lt; config.Config.StorageLineLimit </span><span class="cov0" title="0">{
                        for idx, val := range fi.Available </span><span class="cov0" title="0">{
                                if val == 0 </span><span class="cov0" title="0">{
                                        id := fmt.Sprintf("%s.%d", f, idx)
                                        fi.Available[idx] = 1
                                        fi.Length += 1

                                        datum[constants.ID_KEY] = id
                                        path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, c, f)

                                        lines, err := ReadDataFile(path)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">dataBytes, err := json.Marshal(datum)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if idx &lt; len(lines) </span><span class="cov0" title="0">{
                                                lines[idx] = string(dataBytes)
                                        }</span> else<span class="cov0" title="0"> {
                                                lines = append(lines, string(dataBytes))
                                        }</span>
                                        <span class="cov0" title="0">col := collection.Collections[d][c]
                                        col.Files[f] = fi
                                        collection.Collections[d][c] = col
                                        cPath := fmt.Sprintf("%s/collections.json", config.Config.DataDir)
                                        data, err := json.Marshal(collection.Collections)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if err := os.WriteFile(cPath, data, 0777); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">index.AddToIndex(d, c, datum)
                                        return writeDataFile(path, lines)</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">f := uuid.New().String()
        fi := collection.File{
                Length:    1,
                Available: make([]int, config.Config.StorageLineLimit),
        }

        id := fmt.Sprintf("%s.0", f)
        fi.Available[0] = 1

        datum[constants.ID_KEY] = id
        path := fmt.Sprintf("%s/%s/%s/%s", config.Config.DataDir, d, c, f)

        lines, err := ReadDataFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">dataBytes, err := json.Marshal(datum)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lines = append(lines, string(dataBytes))

        col := collection.Collections[d][c]
        col.Files[f] = fi
        collection.Collections[d][c] = col
        cPath := fmt.Sprintf("%s/collections.json", config.Config.DataDir)
        data, err := json.Marshal(collection.Collections)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(cPath, data, 0777); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">index.AddToIndex(d, c, datum)
        return writeDataFile(path, lines)</span>
}

func ReadDataFile(path string) ([]string, error) <span class="cov8" title="1">{
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                parent := strings.Join(strings.Split(path, "/")[:len(strings.Split(path, "/"))-1], "/")
                os.MkdirAll(parent, 0777)
                return []string{}, nil
        }</span>
        <span class="cov8" title="1">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">data, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">lines := strings.Split(string(data), "\n")
        return lines, nil</span>
}

func writeDataFile(path string, lines []string) error <span class="cov8" title="1">{
        data := strings.Join(lines, "\n")
        err := os.WriteFile(path, []byte(data), 0777)
        return err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package schema

import (
        "ceresdb/config"
        "ceresdb/constants"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
)

var Schemas map[string]map[string]interface{}

func LoadSchemas() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/schemas.json", config.Config.DataDir)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                Schemas = make(map[string]map[string]interface{})
                return saveSchema()
        }</span>

        <span class="cov0" title="0">jsonFile, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">byteValue, err := ioutil.ReadAll(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(byteValue, &amp;Schemas)
        return saveSchema()</span>
}

// Validates if an object matches a schema for a specific database and collectios
// database and collection names are _not_ validated in this function, instead
// they should be validated in the query pre-processor
func ValidateSchema(database string, collection string, data interface{}) error <span class="cov8" title="1">{
        s := Schemas[database][collection]
        return validateDataAgainstSchema(".", s, data)
}</span>

// Traverses the object to check comparing each object to the provided schema
func validateDataAgainstSchema(key string, schema, object interface{}) error <span class="cov8" title="1">{
        if _, ok := schema.(string); ok </span><span class="cov8" title="1">{
                typeName := schema.(string)
                switch typeName </span>{
                case constants.DATATYPE_ANY:<span class="cov0" title="0">
                        return nil</span>
                case constants.DATATYPE_STRING:<span class="cov8" title="1">
                        if _, ok := object.(string); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("value at %s does not match type %s", key, typeName)
                        }</span>
                case constants.DATATYPE_INT:<span class="cov8" title="1">
                        if _, ok := object.(int); !ok </span><span class="cov0" title="0">{
                                if _, ok := object.(float64); !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("value at %s does not match type %s", key, typeName)
                                }</span>
                        }
                case constants.DATATYPE_FLOAT:<span class="cov8" title="1">
                        if _, ok := object.(float64); !ok </span><span class="cov8" title="1">{
                                return fmt.Errorf("value at %s does not match type %s", key, typeName)
                        }</span>
                case constants.DATATYPE_BOOL:<span class="cov8" title="1">
                        if _, ok := object.(bool); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("value at %s does not match type %s", key, typeName)
                        }</span>
                case constants.DATATYPE_BYTE:<span class="cov0" title="0">
                        if _, ok := object.(byte); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("value at %s does not match type %s", key, typeName)
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("invalid type: %s", typeName)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if schemaMap, ok := schema.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if dict, ok := object.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        for child, val := range dict </span><span class="cov8" title="1">{
                                if child == constants.ID_KEY </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if err := validateDataAgainstSchema(fmt.Sprintf("%s.%s", key, child), schemaMap[child], val); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("value at %s does not match type dict", key)</span>
        }

        <span class="cov8" title="1">if list, ok := object.([]interface{}); ok </span><span class="cov8" title="1">{
                for idx, val := range list </span><span class="cov8" title="1">{
                        if err := validateDataAgainstSchema(fmt.Sprintf("%s[%d]", key, idx), schema.([]interface{})[0], val); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("value at %s does not match type list: %v | %v", key, schema, object)</span>

}

// Validates a schema against the grammar
func BuildSchema(database, collection string, schema interface{}) error <span class="cov8" title="1">{
        if err := validateDataAgainstGrammar(".", schema); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if Schemas == nil </span><span class="cov0" title="0">{
                Schemas = map[string]map[string]interface{}{}
        }</span>
        <span class="cov8" title="1">if _, ok := Schemas[database]; !ok </span><span class="cov8" title="1">{
                Schemas[database] = map[string]interface{}{}
        }</span>
        <span class="cov8" title="1">Schemas[database][collection] = schema
        return saveSchema()</span>
}

// Traverses the object to check if each element is a valid schema
func validateDataAgainstGrammar(key string, schema interface{}) error <span class="cov8" title="1">{
        if typeName, ok := schema.(string); ok </span><span class="cov8" title="1">{
                switch typeName </span>{
                case constants.DATATYPE_ANY:<span class="cov0" title="0"></span>
                case constants.DATATYPE_STRING:<span class="cov8" title="1"></span>
                case constants.DATATYPE_INT:<span class="cov8" title="1"></span>
                case constants.DATATYPE_FLOAT:<span class="cov8" title="1"></span>
                case constants.DATATYPE_BOOL:<span class="cov8" title="1"></span>
                case constants.DATATYPE_BYTE:<span class="cov0" title="0"></span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf("invalid type at %s: %s", key, typeName)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if dict, ok := schema.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                for child, val := range dict </span><span class="cov8" title="1">{
                        if err := validateDataAgainstGrammar(fmt.Sprintf("%s.%s", key, child), val); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if list, ok := schema.([]interface{}); ok </span><span class="cov8" title="1">{
                if len(list) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid list specification: %v, list must contain exatly one element representing its type", list)
                }</span>
                <span class="cov8" title="1">return validateDataAgainstGrammar(fmt.Sprintf("%s[0]", key), list[0])</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("value at %s of type %T is invalid", key, schema)</span>
}

func Delete(d, name string) error <span class="cov8" title="1">{
        delete(Schemas[d], name)
        return saveSchema()
}</span>

func saveSchema() error <span class="cov8" title="1">{
        path := fmt.Sprintf("%s/schemas.json", config.Config.DataDir)
        data, err := json.Marshal(Schemas)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, data, 0777)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// utils.go

package utils

import (
        "ceresdb/constants"
        "ceresdb/logger"
        "fmt"
        "sort"
        "strings"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
)

func Error(err error, c *gin.Context, statusCode int) <span class="cov0" title="0">{
        logger.Error("", err.Error())
        c.JSON(statusCode, gin.H{"error": err.Error()})
}</span>

func Index(s []string, e string) int <span class="cov8" title="1">{
        for idx, a := range s </span><span class="cov8" title="1">{
                if a == e </span><span class="cov8" title="1">{
                        return idx
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func Contains(s []string, e string) bool <span class="cov8" title="1">{
        for _, a := range s </span><span class="cov8" title="1">{
                if a == e </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func Remove(s []string, e string) []string <span class="cov8" title="1">{
        for i, a := range s </span><span class="cov8" title="1">{
                if a == e </span><span class="cov8" title="1">{
                        return append(s[:i], s[i+1:]...)
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

func RemoveDuplicateValues(stringSlice []string) []string <span class="cov8" title="1">{
        keys := make(map[string]bool)
        list := []string{}

        // If the key(values of the slice) is not equal
        // to the already present value in new slice (list)
        // then we append it. else we jump on another element.
        for _, entry := range stringSlice </span><span class="cov8" title="1">{
                if _, value := keys[entry]; !value </span><span class="cov8" title="1">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov8" title="1">return list</span>
}

func HashAndSalt(pwd []byte) (string, error) <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return string(hash), nil</span>
}

func AndLists(a, b []string) []string <span class="cov8" title="1">{
        out := []string{}
        for _, val := range a </span><span class="cov8" title="1">{
                if Contains(b, val) </span><span class="cov8" title="1">{
                        out = append(out, val)
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}

func NotLists(a, b []string) []string <span class="cov8" title="1">{
        logger.Tracef("", "Performing not comparison between %s and %s", a, b)
        out := []string{}
        for _, val := range a </span><span class="cov8" title="1">{
                if Contains(b, val) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, val)</span>
        }
        <span class="cov8" title="1">for _, val := range b </span><span class="cov8" title="1">{
                if Contains(a, val) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, val)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func OrLists(a, b []string) []string <span class="cov8" title="1">{
        out := append(a, b...)
        return RemoveDuplicateValues(out)
}</span>

func CompareSlicePattern(a, b []string) bool <span class="cov8" title="1">{
        for idx, aa := range a </span><span class="cov8" title="1">{
                if b[idx] == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">logger.Tracef("", "Comparing %s to %s", strings.ToUpper(aa), strings.ToUpper(b[idx]))
                if strings.ToUpper(aa) != strings.ToUpper(b[idx]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func SortInterfacesDescending(keys []string, objs []interface{}) ([]interface{}, error) <span class="cov0" title="0">{
        dType, err := getType(keys, objs[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">outMap := []map[string]interface{}{}
        for _, obj := range objs </span><span class="cov0" title="0">{
                outMap = append(outMap, map[string]interface{}{
                        "val": getVal(keys, obj),
                        "obj": obj,
                })
        }</span>
        <span class="cov0" title="0">logger.Tracef("", "Descending type: %s", dType)
        switch dType </span>{
        case constants.DATATYPE_STRING:<span class="cov0" title="0">
                logger.Tracef("", "descending type string")
                sort.Slice(outMap,
                        func(i, j int) bool </span><span class="cov0" title="0">{
                                return outMap[i]["val"].(string) &gt; outMap[j]["val"].(string)
                        }</span>)
        case constants.DATATYPE_FLOAT:<span class="cov0" title="0">
                logger.Tracef("", "descending type float")
                sort.Slice(outMap,
                        func(i, j int) bool </span><span class="cov0" title="0">{
                                return outMap[i]["val"].(float64) &gt; outMap[j]["val"].(float64)
                        }</span>)
        case constants.DATATYPE_INT:<span class="cov0" title="0">
                logger.Tracef("", "descending type int")
                sort.Slice(outMap,
                        func(i, j int) bool </span><span class="cov0" title="0">{
                                return outMap[i]["val"].(int) &gt; outMap[j]["val"].(int)
                        }</span>)
        }
        <span class="cov0" title="0">out := []interface{}{}
        for _, obj := range outMap </span><span class="cov0" title="0">{
                out = append(out, obj["obj"])
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func SortInterfacesAscending(keys []string, objs []interface{}) ([]interface{}, error) <span class="cov0" title="0">{
        dType, err := getType(keys, objs[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">outMap := []map[string]interface{}{}
        for _, obj := range objs </span><span class="cov0" title="0">{
                outMap = append(outMap, map[string]interface{}{
                        "val": getVal(keys, obj),
                        "obj": obj,
                })
        }</span>
        <span class="cov0" title="0">switch dType </span>{
        case constants.DATATYPE_STRING:<span class="cov0" title="0">
                sort.Slice(outMap,
                        func(i, j int) bool </span><span class="cov0" title="0">{
                                return outMap[i]["val"].(string) &lt; outMap[j]["val"].(string)
                        }</span>)
        case constants.DATATYPE_FLOAT:<span class="cov0" title="0">
                sort.Slice(outMap,
                        func(i, j int) bool </span><span class="cov0" title="0">{
                                return outMap[i]["val"].(float64) &lt; outMap[j]["val"].(float64)
                        }</span>)
        case constants.DATATYPE_INT:<span class="cov0" title="0">
                sort.Slice(outMap,
                        func(i, j int) bool </span><span class="cov0" title="0">{
                                return outMap[i]["val"].(int) &lt; outMap[j]["val"].(int)
                        }</span>)
        }
        <span class="cov0" title="0">out := []interface{}{}
        for _, obj := range outMap </span><span class="cov0" title="0">{
                out = append(out, obj["obj"])
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func getVal(keys []string, obj interface{}) interface{} <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return obj
        }</span>
        <span class="cov0" title="0">m := obj.(map[string]interface{})
        return getVal(keys[1:], m[keys[0]])</span>
}

func getType(keys []string, obj interface{}) (string, error) <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                if _, ok := obj.(string); ok </span><span class="cov0" title="0">{
                        return constants.DATATYPE_STRING, nil
                }</span>
                <span class="cov0" title="0">if _, ok := obj.(int); ok </span><span class="cov0" title="0">{
                        return constants.DATATYPE_STRING, nil
                }</span>
                <span class="cov0" title="0">if _, ok := obj.(float64); ok </span><span class="cov0" title="0">{
                        return constants.DATATYPE_FLOAT, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("cannot sort, invalid datatype")</span>
        }
        <span class="cov0" title="0">m := obj.(map[string]interface{})
        return getType(keys[1:], m[keys[0]])</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
