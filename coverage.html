
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aql: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ceresdb/aql/aql.go (100.0%)</option>
				
				<option value="file1">ceresdb/collection/collection.go (86.6%)</option>
				
				<option value="file2">ceresdb/config/config.go (82.0%)</option>
				
				<option value="file3">ceresdb/cursor/cursor.go (95.6%)</option>
				
				<option value="file4">ceresdb/database/database.go (82.9%)</option>
				
				<option value="file5">ceresdb/freespace/freespace.go (100.0%)</option>
				
				<option value="file6">ceresdb/index/index.go (87.8%)</option>
				
				<option value="file7">ceresdb/permit/permit.go (100.0%)</option>
				
				<option value="file8">ceresdb/schema/schema.go (98.5%)</option>
				
				<option value="file9">ceresdb/user/user.go (100.0%)</option>
				
				<option value="file10">ceresdb/utils/utils.go (86.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package aql handles Antler Query Language parsing
package aql

import (
        "ceresdb/config"
        "ceresdb/utils"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "regexp"
        "strconv"
        "strings"
)

type Node struct {
        Value string
        Left  *Node
        Right *Node
}

type Token struct {
        Type  string
        Value string
}
type DepthStruct struct {
        Paren   int
        Brace   int
        Bracket int
}

type FlagStruct struct {
        Quote   bool
        Bracket bool
        Brace   bool
        Paren   bool
}

type Action struct {
        Type       string
        Identifier string
        Resource   string
        IDs        []string
        Fields     []string
        Limit      int
        Filter     Node
        Order      string
        OrderDir   string
        Data       []map[string]interface{}
        User       string
}

// Determine the type of a token based on its value
func determineType(value string, token *Token) <span class="cov8" title="1">{
        ops := []string{"&gt;", "&gt;=", "=", "&lt;=", "&lt;", "!="}
        logic := []string{"AND", "OR", "XOR", "NOT"}
        resources := []string{"DATABASE", "RECORD", "COLLECTION", "USER", "PERMIT"}
        switch strings.ToUpper(value) </span>{
        // Grammar
        case ",":<span class="cov8" title="1">
                token.Type = "COMMA"</span>
        case "(":<span class="cov8" title="1">
                token.Type = "OPEN_PAREN"</span>
        case ")":<span class="cov8" title="1">
                token.Type = "CLOSE_PAREN"</span>
        case "[":<span class="cov8" title="1">
                token.Type = "OPEN_BRACKET"</span>
        case "]":<span class="cov8" title="1">
                token.Type = "CLOSE_BRACKET"</span>
        case "{":<span class="cov8" title="1">
                token.Type = "OPEN_BRACE"</span>
        case "}":<span class="cov8" title="1">
                token.Type = "CLOSE_BRACE"</span>
        case "|":<span class="cov8" title="1">
                token.Type = "PIPE"</span>
        case "*":<span class="cov8" title="1">
                token.Type = "WILDCARD"</span>
        case "-":<span class="cov8" title="1">
                token.Type = "DASH"</span>
        // Actions
        case "GET":<span class="cov8" title="1">
                token.Type = "GET"
                token.Value = strings.ToUpper(value)</span>
        case "POST":<span class="cov8" title="1">
                token.Type = "POST"
                token.Value = strings.ToUpper(value)</span>
        case "PUT":<span class="cov8" title="1">
                token.Type = "PUT"
                token.Value = strings.ToUpper(value)</span>
        case "PATCH":<span class="cov8" title="1">
                token.Type = "PATCH"
                token.Value = strings.ToUpper(value)</span>
        case "DELETE":<span class="cov8" title="1">
                token.Type = "DELETE"
                token.Value = strings.ToUpper(value)</span>
        case "COUNT":<span class="cov8" title="1">
                token.Type = "COUNT"
                token.Value = strings.ToUpper(value)</span>
        case "LIMIT":<span class="cov8" title="1">
                token.Type = "LIMIT"
                token.Value = strings.ToUpper(value)</span>
        case "FILTER":<span class="cov8" title="1">
                token.Type = "FILTER"
                token.Value = strings.ToUpper(value)</span>
        case "ORDERASC":<span class="cov8" title="1">
                token.Type = "ORDERASC"
                token.Value = strings.ToUpper(value)</span>
        case "ORDERDSC":<span class="cov8" title="1">
                token.Type = "ORDERDSC"
                token.Value = strings.ToUpper(value)</span>
        default:<span class="cov8" title="1">
                val := strings.ToUpper(value)
                // Check the more open-ended types
                if utils.Contains(ops, val) </span><span class="cov8" title="1">{
                        token.Type = "OP"
                        token.Value = val
                }</span> else<span class="cov8" title="1"> if utils.Contains(resources, val) </span><span class="cov8" title="1">{
                        token.Type = "RESOURCE"
                        token.Value = val
                }</span> else<span class="cov8" title="1"> if utils.Contains(logic, val) </span><span class="cov8" title="1">{
                        token.Type = "LOGIC"
                        token.Value = val
                }</span> else<span class="cov8" title="1"> if value[0:1] == "\"" </span><span class="cov8" title="1">{
                        token.Type = "STRING"
                        token.Value = value[1 : len(value)-1]
                }</span> else<span class="cov8" title="1"> if value[0:1] == "[" </span><span class="cov8" title="1">{
                        token.Type = "LIST"
                }</span> else<span class="cov8" title="1"> if value[0:1] == "{" </span><span class="cov8" title="1">{
                        token.Type = "DICT"
                }</span> else<span class="cov8" title="1"> if value[0:1] == "(" </span><span class="cov8" title="1">{
                        token.Type = "NESTED"
                }</span> else<span class="cov8" title="1"> if res, _ := regexp.MatchString("^-?\\d+$", value); res </span><span class="cov8" title="1">{
                        token.Type = "INT"
                }</span> else<span class="cov8" title="1"> if res, _ := regexp.MatchString("^-?\\d+\\.\\d+$", value); res </span><span class="cov8" title="1">{
                        token.Type = "FLOAT"
                }</span> else<span class="cov8" title="1"> if res, _ := regexp.MatchString("^(?:true|false)$", value); res </span><span class="cov8" title="1">{
                        token.Type = "BOOLEAN"
                }</span> else<span class="cov8" title="1"> if res, _ := regexp.MatchString("^[a-zA-Z0-9-_]+\\.[a-zA-Z0-9-_]+$", value); res </span><span class="cov8" title="1">{
                        token.Type = "IDENTIFIER"
                }</span> else<span class="cov8" title="1"> {
                        token.Type = "FIELD"
                }</span>
        }
}

// Get the patterns which define the AQL language
func getPatterns() (map[string]interface{}, error) <span class="cov8" title="1">{
        path := config.Config.HomeDir + "/config/aql.json"

        // Open our jsonFile
        jsonFile, err := os.Open(path)

        // If we os.Open returns an error then handle it
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Read and unmarshal the JSON
        <span class="cov8" title="1">byteValue, _ := ioutil.ReadAll(jsonFile)

        var output map[string]interface{}

        // Read the JSON
        err = json.Unmarshal(byteValue, &amp;output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return output, nil</span>
}

// Check a provided action against the AQL grammar to ensure that it is syntactically correct
func checkPattern(actionString, actionSyntax, pattern string) error <span class="cov8" title="1">{
        if res, _ := regexp.MatchString(pattern, actionString); !res </span><span class="cov8" title="1">{
                err := errors.New("Invalid syntax: `" + actionSyntax + "`. Got: " + actionString + ", want: " + pattern)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// func printFilter(node Node, indent string) {
//         if indent == "" {
//                 fmt.Print("HEAD  : ")
//         }
//         fmt.Printf("%v%v\n", indent, node.Value)
//         if node.Left != nil {
//                 fmt.Print("LEFT  : ")
//                 printFilter(*node.Left, indent+"  ")
//         }
//         if node.Right != nil {
//                 fmt.Print("RIGHT : ")
//                 printFilter(*node.Right, indent+"  ")
//         }
// }

// Given a list of filter tokens, produce a tree that represents the logical and conditional operations
func handleConditionals(tokens []Token) Node <span class="cov8" title="1">{
        nodes := make([]Node, 0)
        LOGIC := []string{"AND", "OR", "XOR"}

        // Break down the tokens into a list of nodes with operations containing their operands on the
        // left and right sides
        idx := 0
        for idx &lt; len(tokens) </span><span class="cov8" title="1">{
                if tokens[idx].Type == "OP" </span><span class="cov8" title="1">{
                        nodeL := Node{Value: tokens[idx-1].Value}
                        nodeR := Node{Value: tokens[idx+1].Value}
                        nodeC := Node{Value: tokens[idx].Value, Left: &amp;nodeL, Right: &amp;nodeR}
                        nodes = append(nodes, nodeC)
                        idx++
                }</span> else<span class="cov8" title="1"> if utils.Contains(LOGIC, tokens[idx].Value) || tokens[idx].Value == "NOT" || tokens[idx].Type == "NESTED" </span><span class="cov8" title="1">{
                        node := Node{Value: tokens[idx].Value}
                        nodes = append(nodes, node)
                }</span>
                <span class="cov8" title="1">idx++</span>
        }

        <span class="cov8" title="1">var head *Node
        head = &amp;Node{}
        firstPass := true

        // Loop through the nodes and build the tree
        for idx := range nodes </span><span class="cov8" title="1">{
                if utils.Contains(LOGIC, nodes[idx].Value) </span><span class="cov8" title="1">{
                        nodes[idx].Left = head
                        head = &amp;nodes[idx]
                }</span> else<span class="cov8" title="1"> {
                        if strings.HasPrefix(nodes[idx].Value, "(") </span><span class="cov8" title="1">{
                                // If we come across a nested statement then we want to parse that as its own thing
                                // and then just stick the resulting tree in as a node
                                parsed := parseString(nodes[idx].Value[1 : len(nodes[idx].Value)-1])
                                node := handleConditionals(parsed)
                                if firstPass == false </span><span class="cov8" title="1">{
                                        head.Right = &amp;node
                                }</span> else<span class="cov8" title="1"> {
                                        head = &amp;node
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if firstPass == false </span><span class="cov8" title="1">{
                                        head.Right = &amp;nodes[idx]
                                }</span> else<span class="cov8" title="1"> {
                                        head = &amp;nodes[idx]
                                }</span>
                        }
                }
                <span class="cov8" title="1">firstPass = false</span>
        }

        <span class="cov8" title="1">return *head</span>
}

// Parse a list or dictionary into the action's data field
func handleData(token Token, currentAction *Action) error <span class="cov8" title="1">{
        if token.Type == "LIST" </span><span class="cov8" title="1">{
                var d interface{}
                err := json.Unmarshal([]byte(token.Value), &amp;d)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">tmp := make([]map[string]interface{}, 0)
                for _, v := range d.([]interface{}) </span><span class="cov8" title="1">{
                        tmp = append(tmp, v.(map[string]interface{}))
                }</span>
                <span class="cov8" title="1">currentAction.Data = tmp</span>
        } else<span class="cov8" title="1"> {
                var d interface{}
                err := json.Unmarshal([]byte(token.Value), &amp;d)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">tmp := make([]map[string]interface{}, 1)
                tmp[0] = d.(map[string]interface{})
                currentAction.Data = tmp</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Parse a string or list into the action's ID field
func handleIDs(token Token, currentAction *Action) error <span class="cov8" title="1">{
        if token.Type == "LIST" </span><span class="cov8" title="1">{
                var d interface{}
                err := json.Unmarshal([]byte(token.Value), &amp;d)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">tmp := make([]string, 0)
                for _, v := range d.([]interface{}) </span><span class="cov8" title="1">{
                        tmp = append(tmp, v.(string))
                }</span>
                <span class="cov8" title="1">currentAction.IDs = tmp</span>
        } else<span class="cov8" title="1"> {
                currentAction.IDs = []string{token.Value}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Parse a string or list into the action's fields field
func handleFields(token Token, currentAction *Action) error <span class="cov8" title="1">{
        if token.Type == "LIST" </span><span class="cov8" title="1">{
                var d interface{}
                err := json.Unmarshal([]byte(token.Value), &amp;d)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">tmp := make([]string, 0)
                for _, v := range d.([]interface{}) </span><span class="cov8" title="1">{
                        tmp = append(tmp, v.(string))
                }</span>
                <span class="cov8" title="1">currentAction.Fields = tmp</span>
        } else<span class="cov8" title="1"> {
                currentAction.Fields = []string{token.Value}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// buildActions takes a list of tokens and figures out which actions should be created to operate
// within Ceres.
func buildActions(tokens []Token, patterns map[string]interface{}) ([]Action, error) <span class="cov8" title="1">{
        tokenActions := make([][]Token, 0)
        buffer := make([]Token, 0)
        // Break the list of tokens down into a list of sepearate actions that were originally separated
        // by pipe characters
        for _, token := range tokens </span><span class="cov8" title="1">{
                if token.Type != "PIPE" </span><span class="cov8" title="1">{
                        buffer = append(buffer, token)
                }</span> else<span class="cov8" title="1"> {
                        tokenActions = append(tokenActions, buffer)
                        buffer = make([]Token, 0)
                }</span>
        }
        <span class="cov8" title="1">tokenActions = append(tokenActions, buffer)
        actions := make([]Action, 0)

        currentAction := Action{}
        firstFlag := true

        // Look through each action list and build/modify the action object from it
        // TODO: break each "case" out into its own function for readability/maintainability
        for _, tokenAction := range tokenActions </span><span class="cov8" title="1">{
                command := tokenAction[0]
                actionString := ""
                actionSyntax := ""
                for _, token := range tokenAction </span><span class="cov8" title="1">{
                        actionString += token.Type + " "
                        if token.Type != "STRING" </span><span class="cov8" title="1">{
                                actionSyntax += token.Value
                        }</span> else<span class="cov8" title="1"> {
                                actionSyntax += "\"" + token.Value + "\""
                        }</span>
                        <span class="cov8" title="1">actionSyntax += " "</span>
                }
                <span class="cov8" title="1">actionString = actionString[:len(actionString)-1]
                actionSyntax = actionSyntax[:len(actionSyntax)-1]

                switch command.Type </span>{
                case "GET":<span class="cov8" title="1">
                        if !firstFlag </span><span class="cov8" title="1">{
                                actions = append(actions, currentAction)
                        }</span>
                        <span class="cov8" title="1">patternMap := patterns["GET"].(map[string]interface{})
                        if _, ok := patternMap[tokenAction[1].Value]; !ok </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("Invalid resource type %v", tokenAction[1].Value))
                        }</span>
                        <span class="cov8" title="1">pattern := patternMap[tokenAction[1].Value].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction = Action{Type: "GET"}
                        currentAction.Resource = tokenAction[1].Value

                        if currentAction.Resource == "USER" </span><span class="cov8" title="1">{
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        if err := handleFields(tokenAction[2], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        currentAction.Identifier = tokenAction[2].Value
                                }</span>

                                <span class="cov8" title="1">if len(tokenAction) &gt; 3 </span><span class="cov8" title="1">{
                                        if err := handleFields(tokenAction[3], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">firstFlag = false</span>
                case "POST":<span class="cov8" title="1">
                        if !firstFlag </span><span class="cov8" title="1">{
                                actions = append(actions, currentAction)
                        }</span>
                        <span class="cov8" title="1">patternMap := patterns["POST"].(map[string]interface{})
                        if _, ok := patternMap[tokenAction[1].Value]; !ok </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("Invalid resource type %v", tokenAction[1].Value))
                        }</span>
                        <span class="cov8" title="1">pattern := patternMap[tokenAction[1].Value].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction = Action{Type: "POST"}
                        currentAction.Resource = tokenAction[1].Value

                        if currentAction.Resource == "USER" </span><span class="cov8" title="1">{
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        if err := handleData(tokenAction[2], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        currentAction.Identifier = tokenAction[2].Value
                                }</span>

                                <span class="cov8" title="1">if len(tokenAction) &gt; 3 </span><span class="cov8" title="1">{
                                        if err := handleData(tokenAction[3], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">firstFlag = false</span>
                case "PUT":<span class="cov8" title="1">
                        if !firstFlag </span><span class="cov8" title="1">{
                                actions = append(actions, currentAction)
                        }</span>
                        <span class="cov8" title="1">patternMap := patterns["PUT"].(map[string]interface{})
                        if _, ok := patternMap[tokenAction[1].Value]; !ok </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("Invalid resource type %v", tokenAction[1].Value))
                        }</span>
                        <span class="cov8" title="1">pattern := patternMap[tokenAction[1].Value].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction = Action{Type: "PUT"}
                        currentAction.Resource = tokenAction[1].Value

                        if currentAction.Resource == "USER" </span><span class="cov8" title="1">{
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        if err := handleData(tokenAction[2], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        currentAction.Identifier = tokenAction[2].Value
                                }</span>

                                <span class="cov8" title="1">if len(tokenAction) &gt; 3 </span><span class="cov8" title="1">{
                                        if err := handleData(tokenAction[3], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">firstFlag = false</span>
                case "PATCH":<span class="cov8" title="1">
                        if !firstFlag </span><span class="cov8" title="1">{
                                actions = append(actions, currentAction)
                        }</span>
                        <span class="cov8" title="1">patternMap := patterns["PATCH"].(map[string]interface{})
                        if _, ok := patternMap[tokenAction[1].Value]; !ok </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("Invalid resource type %v", tokenAction[1].Value))
                        }</span>
                        <span class="cov8" title="1">pattern := patternMap[tokenAction[1].Value].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction = Action{Type: "PATCH"}
                        currentAction.Resource = tokenAction[1].Value

                        if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                currentAction.Identifier = tokenAction[2].Value
                        }</span>
                        <span class="cov8" title="1">if len(tokenAction) &gt; 3 </span><span class="cov8" title="1">{
                                if err := handleIDs(tokenAction[3], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov8" title="1">if len(tokenAction) &gt; 4 </span><span class="cov8" title="1">{
                                if err := handleData(tokenAction[4], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                        }

                        <span class="cov8" title="1">firstFlag = false</span>
                case "DELETE":<span class="cov8" title="1">
                        if !firstFlag </span><span class="cov8" title="1">{
                                actions = append(actions, currentAction)
                        }</span>
                        <span class="cov8" title="1">patternMap := patterns["DELETE"].(map[string]interface{})
                        if _, ok := patternMap[tokenAction[1].Value]; !ok </span><span class="cov8" title="1">{
                                return nil, errors.New(fmt.Sprintf("Invalid resource type %v", tokenAction[1].Value))
                        }</span>
                        <span class="cov8" title="1">pattern := patternMap[tokenAction[1].Value].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction = Action{Type: "DELETE"}
                        currentAction.Resource = tokenAction[1].Value

                        if currentAction.Resource == "USER" </span><span class="cov8" title="1">{
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        if err := handleIDs(tokenAction[2], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                if len(tokenAction) &gt; 2 </span><span class="cov8" title="1">{
                                        currentAction.Identifier = tokenAction[2].Value
                                }</span>

                                <span class="cov8" title="1">if len(tokenAction) &gt; 3 </span><span class="cov8" title="1">{
                                        if err := handleIDs(tokenAction[3], &amp;currentAction); err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">firstFlag = false</span>
                case "COUNT":<span class="cov8" title="1">
                        if !firstFlag </span><span class="cov8" title="1">{
                                actions = append(actions, currentAction)
                        }</span>
                        <span class="cov8" title="1">pattern := patterns["COUNT"].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction = Action{Type: "COUNT"}
                        firstFlag = false</span>
                case "FILTER":<span class="cov8" title="1">
                        pattern := patterns["FILTER"].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction.Filter = handleConditionals(tokenAction[1:])</span>
                case "LIMIT":<span class="cov8" title="1">
                        pattern := patterns["LIMIT"].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">val, err := strconv.Atoi(tokenAction[1].Value)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction.Limit = val</span>
                case "ORDERASC":<span class="cov8" title="1">
                        pattern := patterns["ORDERASC"].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction.OrderDir = "ASC"
                        currentAction.Order = tokenAction[1].Value</span>
                case "ORDERDSC":<span class="cov8" title="1">
                        pattern := patterns["ORDERDSC"].(string)
                        if err := checkPattern(actionString, actionSyntax, pattern); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">currentAction.OrderDir = "DSC"
                        currentAction.Order = tokenAction[1].Value</span>
                }
        }
        <span class="cov8" title="1">actions = append(actions, currentAction)
        return actions, nil</span>
}

// parseString builds a list of tokens based off of a string of text.
func parseString(input string) []Token <span class="cov8" title="1">{
        text := strings.Split(input, "")
        depths := DepthStruct{Paren: 0, Brace: 0, Bracket: 0}
        flags := FlagStruct{Quote: false}
        buffer := ""
        tokens := make([]Token, 0)

        for idx, char := range text </span><span class="cov8" title="1">{
                look_behind := ""
                if idx &gt; 0 </span><span class="cov8" title="1">{
                        look_behind = text[idx-1]
                }</span>
                <span class="cov8" title="1">if char == "\"" &amp;&amp; look_behind != "\\" </span><span class="cov8" title="1">{
                        flags.Quote = !flags.Quote
                        buffer += char
                }</span> else<span class="cov8" title="1"> {
                        if !flags.Quote </span><span class="cov8" title="1">{
                                switch char </span>{
                                case "(":<span class="cov8" title="1">
                                        if depths.Paren == 0 </span><span class="cov8" title="1">{
                                                flags.Paren = true
                                        }</span>
                                        <span class="cov8" title="1">depths.Paren += 1
                                        buffer += char</span>
                                case ")":<span class="cov8" title="1">
                                        depths.Paren -= 1
                                        buffer += char
                                        if depths.Paren == 0 </span><span class="cov8" title="1">{
                                                flags.Paren = false
                                        }</span>
                                case "[":<span class="cov8" title="1">
                                        if depths.Bracket == 0 </span><span class="cov8" title="1">{
                                                flags.Bracket = true
                                        }</span>
                                        <span class="cov8" title="1">depths.Bracket += 1
                                        buffer += char</span>
                                case "]":<span class="cov8" title="1">
                                        depths.Bracket -= 1
                                        buffer += char
                                        if depths.Bracket == 0 </span><span class="cov8" title="1">{
                                                flags.Bracket = false
                                        }</span>
                                case "{":<span class="cov8" title="1">
                                        if depths.Brace == 0 </span><span class="cov8" title="1">{
                                                flags.Brace = true
                                        }</span>
                                        <span class="cov8" title="1">depths.Brace += 1
                                        buffer += char</span>
                                case "}":<span class="cov8" title="1">
                                        depths.Brace -= 1
                                        buffer += char
                                        if depths.Brace == 0 </span><span class="cov8" title="1">{
                                                flags.Brace = false
                                        }</span>
                                case " ":<span class="cov8" title="1">
                                        if flags.Bracket || flags.Brace || flags.Paren </span><span class="cov8" title="1">{
                                                buffer += char
                                        }</span> else<span class="cov8" title="1"> {
                                                child := Token{Value: buffer}
                                                determineType(buffer, &amp;child)
                                                tokens = append(tokens, child)
                                                buffer = ""
                                        }</span>
                                case ",":<span class="cov8" title="1">
                                        if flags.Bracket || flags.Brace || flags.Paren </span><span class="cov8" title="1">{
                                                buffer += char
                                        }</span> else<span class="cov8" title="1"> {
                                                child1 := Token{Value: buffer}
                                                determineType(buffer, &amp;child1)
                                                tokens = append(tokens, child1)

                                                child2 := Token{Value: ","}
                                                determineType(buffer, &amp;child2)
                                                tokens = append(tokens, child2)
                                        }</span>
                                default:<span class="cov8" title="1">
                                        buffer += char</span>
                                }
                        } else<span class="cov8" title="1"> {
                                buffer += char
                        }</span>
                }
        }
        <span class="cov8" title="1">child := Token{Value: buffer}
        determineType(buffer, &amp;child)
        tokens = append(tokens, child)

        return tokens</span>

}

// Parse processes input and get the actions as a result.
// Actions are verified against the AQL grammar for correctness.
func Parse(input string) ([]Action, error) <span class="cov8" title="1">{
        tokens := parseString(input)
        patterns, err := getPatterns()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">actions, err := buildActions(tokens, patterns)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return actions, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package collection

import (
        "ceresdb/config"
        "ceresdb/freespace"
        "ceresdb/schema"
        "errors"
        "io/ioutil"
        "os"
        "path/filepath"
)

func Delete(database, collection string) error <span class="cov8" title="1">{
        dataPath := filepath.Join(config.Config.DataDir, database, collection)
        indexPath := filepath.Join(config.Config.IndexDir, database, collection)
        if err := os.RemoveAll(dataPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.RemoveAll(indexPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">freespaceDB := freespace.FreeSpace.Databases[database]
        delete(freespaceDB.Collections, collection)
        freespace.FreeSpace.Databases[database] = freespaceDB
        schemaDB := schema.Schema.Databases[database]
        delete(schemaDB.Collections, collection)
        schema.Schema.Databases[database] = schemaDB
        freespace.WriteFreeSpace()
        schema.WriteSchema()
        return nil</span>
}

func Get(database string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var collections []map[string]interface{}
        dirInfo, err := ioutil.ReadDir(filepath.Join(config.Config.DataDir, database))
        if err != nil </span><span class="cov0" title="0">{
                return collections, err
        }</span>

        <span class="cov8" title="1">for _, dir := range dirInfo </span><span class="cov8" title="1">{
                collections = append(collections, map[string]interface{}{"name": dir.Name(), "schema": schema.Schema.Databases[database].Collections[dir.Name()].Types})
        }</span>
        <span class="cov8" title="1">return collections, nil</span>
}

func Patch() error <span class="cov8" title="1">{
        return errors.New("PATCH action is unsupported on resource COLLECTION")
}</span>

func Post(database, collection string, newSchema map[string]interface{}) error <span class="cov8" title="1">{
        schemaTypes := make(map[string]string)
        for k, v := range newSchema </span><span class="cov8" title="1">{
                schemaTypes[k] = v.(string)
        }</span>
        <span class="cov8" title="1">if err := schema.ValidateSchemaCollection(schemaTypes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dataPath := filepath.Join(config.Config.DataDir, database, collection)
        indexPath := filepath.Join(config.Config.IndexDir, database, collection)
        if err := os.MkdirAll(dataPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(indexPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">allPath := filepath.Join(config.Config.IndexDir, database, collection, "all")
        os.WriteFile(allPath, []byte(""), 0644)
        freespaceDB := freespace.FreeSpace.Databases[database]
        if freespaceDB.Collections == nil </span><span class="cov8" title="1">{
                freespaceDB.Collections = make(map[string]freespace.FreeSpaceCollection)
        }</span>
        <span class="cov8" title="1">freespaceDB.Collections[collection] = freespace.FreeSpaceCollection{}
        freespace.FreeSpace.Databases[database] = freespaceDB
        schemaDB := schema.Schema.Databases[database]
        schemaCol := schema.SchemaCollection{}
        if schemaDB.Collections == nil </span><span class="cov8" title="1">{
                schemaDB.Collections = make(map[string]schema.SchemaCollection)
        }</span>
        <span class="cov8" title="1">if val, ok := schemaDB.Collections[collection]; ok </span><span class="cov0" title="0">{
                schemaCol = val
        }</span>
        <span class="cov8" title="1">schemaCol.Types = schemaTypes
        schemaDB.Collections[collection] = schemaCol
        schema.Schema.Databases[database] = schemaDB
        freespace.WriteFreeSpace()
        schema.WriteSchema()
        return nil</span>
}

func Put(database, collection string, newSchema map[string]interface{}) error <span class="cov8" title="1">{
        schemaDB := schema.Schema.Databases[database]
        schemaCol := schema.SchemaCollection{}
        schemaTypes := make(map[string]string)
        if schemaDB.Collections == nil </span><span class="cov0" title="0">{
                schemaDB.Collections = make(map[string]schema.SchemaCollection)
        }</span>
        <span class="cov8" title="1">for k, v := range newSchema </span><span class="cov8" title="1">{
                schemaTypes[k] = v.(string)
        }</span>
        <span class="cov8" title="1">if err := schema.ValidateSchemaCollection(schemaTypes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">schemaCol.Types = schemaTypes
        schemaDB.Collections[collection] = schemaCol
        schema.Schema.Databases[database] = schemaDB
        schema.WriteSchema()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// config.go

package config

import (
        "encoding/json"
        "io/ioutil"
        "os"
        "os/user"
        "path/filepath"
        "reflect"
        "strconv"
        "strings"
)

type ConfigObject struct {
        LogLevel         string `json:"log-level" binding:"required" env:"CERESDB_LOG_LEVEL"`
        HomeDir          string `json:"home-dir" binding:"required" env:"CERESDB_HOME_DIR"`
        DataDir          string `json:"data-dir" binding:"required" env:"CERESDB_DATA_DIR"`
        IndexDir         string `json:"index-dir" binding:"required" env:"CERESDB_INDEX_DIR"`
        StorageLineLimit int    `json:"storage-line-limit" binding:"required" env:"CERESDB_STORAGE_LINE_LIMIT"`
        Port             int    `json:"port" binding:"required" env:"CERESDB_PORT"`
}

var Config ConfigObject

func ReadConfigFile() *ConfigObject <span class="cov8" title="1">{

        // Set default path if we are not passed one
        path := os.Getenv("CERESDB_CONFIG_PATH")
        if path == "" </span><span class="cov8" title="1">{
                path = ".ceresdb/config/config.json"
        }</span>

        // Open our jsonFile
        <span class="cov8" title="1">jsonFile, err := os.Open(path)

        // If os.Open returns an error then handle it
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }

        // Read and unmarshal the JSON
        <span class="cov8" title="1">byteValue, _ := ioutil.ReadAll(jsonFile)
        json.Unmarshal(byteValue, &amp;Config)

        v := reflect.ValueOf(Config)
        t := reflect.TypeOf(Config)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                field, found := t.FieldByName(v.Type().Field(i).Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">value := field.Tag.Get("env")
                if value != "" </span><span class="cov8" title="1">{
                        val, present := os.LookupEnv(value)
                        if present </span><span class="cov8" title="1">{
                                w := reflect.ValueOf(&amp;Config).Elem().FieldByName(t.Field(i).Name)
                                x := getAttr(&amp;Config, t.Field(i).Name).Kind().String()
                                if w.IsValid() </span><span class="cov8" title="1">{
                                        switch x </span>{
                                        case "int", "int64":<span class="cov8" title="1">
                                                i, err := strconv.ParseInt(val, 10, 64)
                                                if err == nil </span><span class="cov8" title="1">{
                                                        w.SetInt(i)
                                                }</span>
                                        // case "int8":
                                        //         i, err := strconv.ParseInt(val, 10, 8)
                                        //         if err == nil {
                                        //                 w.SetInt(i)
                                        //         }
                                        // case "int16":
                                        //         i, err := strconv.ParseInt(val, 10, 16)
                                        //         if err == nil {
                                        //                 w.SetInt(i)
                                        //         }
                                        // case "int32":
                                        //         i, err := strconv.ParseInt(val, 10, 32)
                                        //         if err == nil {
                                        //                 w.SetInt(i)
                                        //         }
                                        case "string":<span class="cov8" title="1">
                                                w.SetString(val)</span>
                                                // case "float32":
                                                //         i, err := strconv.ParseFloat(val, 32)
                                                //         if err == nil {
                                                //                 w.SetFloat(i)
                                                //         }
                                                // case "float", "float64":
                                                //         i, err := strconv.ParseFloat(val, 64)
                                                //         if err == nil {
                                                //                 w.SetFloat(i)
                                                //         }
                                                // case "bool":
                                                //         i, err := strconv.ParseBool(val)
                                                //         if err == nil {
                                                //                 w.SetBool(i)
                                                //         }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">defer jsonFile.Close()

        usr, _ := user.Current()
        dir := usr.HomeDir

        // Expand home directory
        if Config.HomeDir == "~" </span><span class="cov0" title="0">{
                Config.HomeDir = dir
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(Config.HomeDir, "~/") </span><span class="cov0" title="0">{
                Config.HomeDir = filepath.Join(dir, Config.HomeDir[2:])
        }</span>
        <span class="cov8" title="1">if Config.DataDir == "~" </span><span class="cov0" title="0">{
                Config.DataDir = dir
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(Config.DataDir, "~/") </span><span class="cov0" title="0">{
                Config.DataDir = filepath.Join(dir, Config.DataDir[2:])
        }</span>
        <span class="cov8" title="1">if Config.IndexDir == "~" </span><span class="cov0" title="0">{
                Config.IndexDir = dir
        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(Config.IndexDir, "~/") </span><span class="cov0" title="0">{
                Config.IndexDir = filepath.Join(dir, Config.IndexDir[2:])
        }</span>

        <span class="cov8" title="1">return &amp;Config</span>
}

func getAttr(obj interface{}, fieldName string) reflect.Value <span class="cov8" title="1">{
        pointToStruct := reflect.ValueOf(obj) // addressable
        curStruct := pointToStruct.Elem()
        if curStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                panic("not struct")</span>
        }
        <span class="cov8" title="1">curField := curStruct.FieldByName(fieldName) // type: reflect.Value
        if !curField.IsValid() </span><span class="cov0" title="0">{
                panic("not found:" + fieldName)</span>
        }
        <span class="cov8" title="1">return curField</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// cursor.go

package cursor

import (
        "encoding/json"
)

type IOMode int64
type IOOp int64

const (
        ModeRead IOMode = iota
        ModeWrite
        ModeDelete
        ModePatch
)

const (
        OpRead IOOp = iota
        OpWrite
        OpDelete
        OpNext
        OpJump
        OpError
)

var Index int
var Mode IOMode
var LowerBound int
var UpperBound int

func Initialize(lowerBound, upperBound int, mode IOMode) <span class="cov8" title="1">{
        Index = -1
        Mode = mode
        LowerBound = lowerBound
        UpperBound = upperBound
}</span>

func Next(line string, datum map[string]interface{}) (IOOp, map[string]interface{}, string, error) <span class="cov8" title="1">{
        Index += 1
        if Index &gt;= LowerBound &amp;&amp; Index &lt;= UpperBound </span><span class="cov8" title="1">{
                switch Mode </span>{
                case ModeRead:<span class="cov8" title="1">
                        var outInterface map[string]interface{}
                        if line == "" </span><span class="cov0" title="0">{
                                return OpRead, outInterface, "", nil
                        }</span>
                        <span class="cov8" title="1">err := json.Unmarshal([]byte(line), &amp;outInterface)
                        if err != nil </span><span class="cov8" title="1">{
                                return OpError, nil, "", err
                        }</span>
                        <span class="cov8" title="1">return OpRead, outInterface, "", nil</span>
                case ModeWrite:<span class="cov8" title="1">
                        var outString string
                        var outInterface map[string]interface{}
                        json.Unmarshal([]byte(line), &amp;outInterface)
                        outBytes, err := json.Marshal(datum)
                        if err != nil </span><span class="cov8" title="1">{
                                return OpError, nil, "", err
                        }</span>
                        <span class="cov8" title="1">outString = string(outBytes) + "\n"
                        return OpWrite, outInterface, outString, nil</span>
                case ModeDelete:<span class="cov8" title="1">
                        var outString string
                        var outInterface map[string]interface{}
                        outString = "\n"
                        json.Unmarshal([]byte(line), &amp;outInterface)
                        return OpDelete, outInterface, outString, nil</span>
                case ModePatch:<span class="cov8" title="1">
                        var outString string
                        var outInterface map[string]interface{}
                        tmpInterface := make(map[string]interface{})
                        json.Unmarshal([]byte(line), &amp;outInterface)
                        for key, val := range outInterface </span><span class="cov8" title="1">{
                                if _, ok := datum[key]; !ok </span><span class="cov8" title="1">{
                                        tmpInterface[key] = val
                                }</span> else<span class="cov8" title="1"> {
                                        tmpInterface[key] = datum[key]
                                }</span>
                        }
                        <span class="cov8" title="1">outBytes, err := json.Marshal(tmpInterface)
                        if err != nil </span><span class="cov0" title="0">{
                                return OpError, nil, "", err
                        }</span>
                        <span class="cov8" title="1">outString = string(outBytes) + "\n"
                        return OpWrite, outInterface, outString, nil</span>
                }
        }
        <span class="cov8" title="1">if Index == UpperBound+1 </span><span class="cov8" title="1">{
                return OpNext, nil, "", nil
        }</span>
        <span class="cov8" title="1">return OpJump, nil, "", nil</span>
}

func Advance(lowerBound, upperBound int) <span class="cov8" title="1">{
        LowerBound = lowerBound
        UpperBound = upperBound
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "ceresdb/collection"
        "ceresdb/config"
        "ceresdb/freespace"
        "ceresdb/record"
        "ceresdb/schema"
        "errors"
        "io/ioutil"
        "os"
        "path/filepath"
)

func Delete(database string) error <span class="cov8" title="1">{
        dataPath := filepath.Join(config.Config.DataDir, database)
        indexPath := filepath.Join(config.Config.IndexDir, database)
        if err := os.RemoveAll(dataPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.RemoveAll(indexPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">delete(freespace.FreeSpace.Databases, database)
        delete(schema.Schema.Databases, database)
        return nil</span>
}

func Get() ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var databases []map[string]interface{}
        dirInfo, err := ioutil.ReadDir(config.Config.DataDir)
        if err != nil </span><span class="cov0" title="0">{
                return databases, err
        }</span>

        <span class="cov8" title="1">for _, dir := range dirInfo </span><span class="cov8" title="1">{
                databases = append(databases, map[string]interface{}{"name": dir.Name()})
        }</span>
        <span class="cov8" title="1">return databases, nil</span>
}

func Patch() error <span class="cov8" title="1">{
        return errors.New("PATCH action is unsupported on resource DATABASE")
}</span>

func Post(database string) error <span class="cov8" title="1">{
        dataPath := filepath.Join(config.Config.DataDir, database)
        indexPath := filepath.Join(config.Config.IndexDir, database)
        if err := os.MkdirAll(dataPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(indexPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">freespace.FreeSpace.Databases[database] = freespace.FreeSpaceDatabase{}
        schema.Schema.Databases[database] = schema.SchemaDatabase{}
        freespace.WriteFreeSpace()
        schema.WriteSchema()
        if database != "_auth" </span><span class="cov8" title="1">{
                collection.Post(database, "_users", map[string]interface{}{"username": "STRING", "role": "STRING"})
                inputData := []map[string]interface{}{{"username": "ceresdb", "role": "ADMIN"}}
                err := record.Post(database, "_users", inputData)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func Put() error <span class="cov8" title="1">{
        return errors.New("PUT action is unsupported on resource DATABASE")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// schema.go

package freespace

import (
        "ceresdb/config"
        "encoding/json"
        "io/ioutil"
        "os"
        "path/filepath"
)

type FreeSpaceFile struct {
        Full   bool    `json:"full"`
        Blocks [][]int `json:"blocks"`
}

type FreeSpaceCollection struct {
        Files map[string]FreeSpaceFile
}

type FreeSpaceDatabase struct {
        Collections map[string]FreeSpaceCollection
}

type FreeSpaceStruct struct {
        Databases map[string]FreeSpaceDatabase
}

var FreeSpace FreeSpaceStruct

func LoadFreeSpace() error <span class="cov8" title="1">{
        path := filepath.Join(config.Config.HomeDir, "free_space.json")

        // Open our jsonFile
        jsonFile, err := os.Open(path)

        // If os.Open returns an error then handle it
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Read and unmarshal the JSON
        <span class="cov8" title="1">byteValue, _ := ioutil.ReadAll(jsonFile)

        var f interface{}

        // Read the JSON
        err = json.Unmarshal(byteValue, &amp;f)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">itemsMap := f.(map[string]interface{})
        FreeSpace.Databases = make(map[string]FreeSpaceDatabase)

        // Loop through the top-level items (database names)
        for dbKey, dbVal := range itemsMap </span><span class="cov8" title="1">{
                dbItem := FreeSpaceDatabase{}
                dbItem.Collections = make(map[string]FreeSpaceCollection)
                dbItemsMap := dbVal.(map[string]interface{})

                // Loop through the 2nd-level items (collection names)
                for colKey, colVal := range dbItemsMap </span><span class="cov8" title="1">{
                        colItem := FreeSpaceCollection{}
                        colItem.Files = make(map[string]FreeSpaceFile)
                        colItemsMap := colVal.(map[string]interface{})

                        // Loop through the 3rd-level items (file names)
                        for fileKey, fileVal := range colItemsMap </span><span class="cov8" title="1">{
                                fileItem := FreeSpaceFile{}
                                fileItemsMap := fileVal.(map[string]interface{})
                                fileItem.Full = fileItemsMap["full"].(bool)
                                blocksItem := make([][]int, 0)
                                blocksItemList := fileItemsMap["blocks"].([]interface{})

                                // Loop through the block items
                                for _, blockVal := range blocksItemList </span><span class="cov8" title="1">{
                                        blockItem := make([]int, 0)
                                        blockItemList := blockVal.([]interface{})
                                        for _, idxVal := range blockItemList </span><span class="cov8" title="1">{
                                                blockItem = append(blockItem, int(idxVal.(float64)))
                                        }</span>
                                        <span class="cov8" title="1">blocksItem = append(blocksItem, blockItem)</span>
                                }

                                <span class="cov8" title="1">fileItem.Blocks = blocksItem
                                colItem.Files[fileKey] = fileItem</span>
                        }
                        <span class="cov8" title="1">dbItem.Collections[colKey] = colItem</span>
                }
                <span class="cov8" title="1">FreeSpace.Databases[dbKey] = dbItem</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func WriteFreeSpace() error <span class="cov8" title="1">{
        path := filepath.Join(config.Config.HomeDir, "free_space.json")

        output := make(map[string]interface{})
        for dbKey, db := range FreeSpace.Databases </span><span class="cov8" title="1">{
                dbInterface := make(map[string]interface{})
                for colKey, col := range db.Collections </span><span class="cov8" title="1">{
                        colInterface := make(map[string]interface{})
                        for fileKey, file := range col.Files </span><span class="cov8" title="1">{
                                fileInterface := map[string]interface{}{"full": file.Full, "blocks": file.Blocks}
                                colInterface[fileKey] = fileInterface
                        }</span>
                        <span class="cov8" title="1">dbInterface[colKey] = colInterface</span>
                }
                <span class="cov8" title="1">output[dbKey] = dbInterface</span>
        }

        <span class="cov8" title="1">freeSpaceContents, _ := json.MarshalIndent(output, "", "    ")
        _ = ioutil.WriteFile(path, freeSpaceContents, 0644)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// index.go

package index

import (
        "ceresdb/config"
        "ceresdb/utils"
        "encoding/base64"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
)

var InvalidSchemaTypes = []string{"DICT", "LIST", "ANY"}

func Add(database, collection string, datum map[string]interface{}, schemaData map[string]string) error <span class="cov8" title="1">{
        log.Println("Adding indices")
        for key, val := range datum </span><span class="cov8" title="1">{
                log.Printf("Key: %v, value: %v", key, val)
                if utils.Contains(InvalidSchemaTypes, schemaData[key]) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if key == ".id" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if key == "password" &amp;&amp; database == "_auth" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := val.([]interface{}); ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">stringVal := fmt.Sprintf("%v", val)
                encodedVal := base64.StdEncoding.EncodeToString([]byte(stringVal))
                dirPath := filepath.Join(config.Config.IndexDir, database, collection, key)
                filePath := filepath.Join(dirPath, encodedVal)
                allPath := filepath.Join(config.Config.IndexDir, database, collection, "all")
                if _, err := os.Stat(dirPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        err = os.MkdirAll(dirPath, 0755)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">f, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = f.WriteString(datum[".id"].(string) + "\n")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">f.Close()
                f, err = os.OpenFile(allPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = f.WriteString(datum[".id"].(string) + "\n")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">f.Close()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func Delete(database, collection string, datum map[string]interface{}, schemaData map[string]string) error <span class="cov8" title="1">{
        for key, val := range datum </span><span class="cov8" title="1">{
                if key == ".id" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if key == "password" &amp;&amp; database == "_auth" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if utils.Contains(InvalidSchemaTypes, schemaData[key]) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">stringVal := fmt.Sprintf("%v", val)
                encodedVal := base64.StdEncoding.EncodeToString([]byte(stringVal))
                filePath := filepath.Join(config.Config.IndexDir, database, collection, key, encodedVal)
                data, err := os.ReadFile(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">indices := strings.Split(string(data), "\n")
                indices = removeIndex(indices, datum[".id"].(string))
                if len(indices) == 1 </span><span class="cov8" title="1">{
                        if err = os.Remove(filePath); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        os.WriteFile(filePath, []byte(strings.Join(indices, "\n")), 0644)
                }</span>
                <span class="cov8" title="1">allPath := filepath.Join(config.Config.IndexDir, database, collection, "all")
                data, err = os.ReadFile(allPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">indices = strings.Split(string(data), "\n")
                indices = removeIndex(indices, datum[".id"].(string))
                os.WriteFile(allPath, []byte(strings.Join(indices, "\n")), 0644)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func Update(database, collection string, oldDatum, newDatum map[string]interface{}, schemaData map[string]string) error <span class="cov8" title="1">{
        if err := Delete(database, collection, oldDatum, schemaData); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Add(database, collection, newDatum, schemaData); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func Get(database, collection, key, value string) ([]string, error) <span class="cov8" title="1">{
        encodedVal := base64.StdEncoding.EncodeToString([]byte(value))
        filePath := filepath.Join(config.Config.IndexDir, database, collection, key, encodedVal)
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">indices := strings.Split(string(data), "\n")
        return indices[:len(indices)-1], nil</span>
}

func All(database, collection string) ([]string, error) <span class="cov8" title="1">{
        filePath := filepath.Join(config.Config.IndexDir, database, collection, "all")
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">indices := strings.Split(string(data), "\n")
        return indices[:len(indices)-1], nil</span>
}

func removeIndex(indices []string, index string) []string <span class="cov8" title="1">{
        idx := linearSearch(indices, index)
        if idx != -1 </span><span class="cov8" title="1">{
                return append(indices[:idx], indices[idx+1:]...)
        }</span>
        <span class="cov8" title="1">return indices</span>
}

func linearSearch(s []string, val string) int <span class="cov8" title="1">{
        for i, v := range s </span><span class="cov8" title="1">{
                if v == val </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package permit

import (
        "ceresdb/record"
        "errors"
)

func Delete(database string, ids []string) error <span class="cov8" title="1">{
        err := record.Delete(database, "_users", ids)
        return err
}</span>

func Get(database string, ids []string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := record.Get(database, "_users", ids)
        return data, err
}</span>

func Patch() error <span class="cov8" title="1">{
        return errors.New("PATCH action is unsupported on resource PERMIT")
}</span>

func Post(database string, data []map[string]interface{}) error <span class="cov8" title="1">{
        err := record.Post(database, "_users", data)
        return err
}</span>

func Put(database string, data []map[string]interface{}) error <span class="cov8" title="1">{
        err := record.Put(database, "_users", data)
        return err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// schema.go

package schema

import (
        "ceresdb/config"
        "ceresdb/utils"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
)

type SchemaCollection struct {
        Types map[string]string
}

type SchemaDatabase struct {
        Collections map[string]SchemaCollection
}

type SchemaStruct struct {
        Databases map[string]SchemaDatabase
}

var Schema SchemaStruct

func LoadSchema() error <span class="cov8" title="1">{
        path := filepath.Join(config.Config.HomeDir, "schema.json")

        // Open our jsonFile
        jsonFile, err := os.Open(path)

        // If os.Open returns an error then handle it
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Read and unmarshal the JSON
        <span class="cov8" title="1">byteValue, _ := ioutil.ReadAll(jsonFile)

        var f interface{}

        // Read the JSON
        err = json.Unmarshal(byteValue, &amp;f)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">itemsMap := f.(map[string]interface{})
        Schema.Databases = make(map[string]SchemaDatabase)

        // Loop through the top-level items (database names)
        for dbKey, dbVal := range itemsMap </span><span class="cov8" title="1">{
                dbItem := SchemaDatabase{}
                dbItem.Collections = make(map[string]SchemaCollection)
                dbItemsMap := dbVal.(map[string]interface{})

                // Loop through the 2nd-level items (collection names)
                for colKey, colVal := range dbItemsMap </span><span class="cov8" title="1">{
                        colItem := SchemaCollection{}
                        colItem.Types = make(map[string]string)
                        colItemsMap := colVal.(map[string]interface{})

                        // Loop through the 3rd-level items (types)
                        for typeKey, typeVal := range colItemsMap </span><span class="cov8" title="1">{
                                colItem.Types[typeKey] = typeVal.(string)
                        }</span>

                        <span class="cov8" title="1">dbItem.Collections[colKey] = colItem</span>
                }
                <span class="cov8" title="1">Schema.Databases[dbKey] = dbItem</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func WriteSchema() error <span class="cov8" title="1">{
        path := filepath.Join(config.Config.HomeDir, "schema.json")

        output := make(map[string]interface{})
        for dbKey, db := range Schema.Databases </span><span class="cov8" title="1">{
                dbInterface := make(map[string]interface{})
                for colKey, col := range db.Collections </span><span class="cov8" title="1">{
                        colInterface := make(map[string]string)
                        for typeKey, typeVal := range col.Types </span><span class="cov8" title="1">{

                                colInterface[typeKey] = typeVal
                        }</span>
                        <span class="cov8" title="1">dbInterface[colKey] = colInterface</span>
                }
                <span class="cov8" title="1">output[dbKey] = dbInterface</span>
        }

        <span class="cov8" title="1">freeSpaceContents, _ := json.MarshalIndent(output, "", "    ")
        _ = ioutil.WriteFile(path, freeSpaceContents, 0644)

        return nil</span>
}

func ValidateSchemaCollection(schemaCollection map[string]string) error <span class="cov8" title="1">{
        validTypes := []string{"INT", "BOOL", "FLOAT", "STRING", "DICT", "LIST", "ANY"}
        for _, val := range schemaCollection </span><span class="cov8" title="1">{
                if !utils.Contains(validTypes, val) </span><span class="cov8" title="1">{
                        return errors.New(fmt.Sprintf("Invalid schema type: %v, valid types are 'INT', 'BOOL', 'FLOAT', 'STRING', 'DICT', 'LIST', or 'ANY'", val))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func Get(database, collection string) map[string]string <span class="cov0" title="0">{
        return Schema.Databases[database].Collections[collection].Types
}</span>

func ValidateDataAgainstSchema(database, collection string, data []map[string]interface{}) error <span class="cov8" title="1">{
        schemaCollection := Schema.Databases[database].Collections[collection]
        for idx, datum := range data </span><span class="cov8" title="1">{
                for key, val := range datum </span><span class="cov8" title="1">{
                        if key == ".id" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ok := schemaCollection.Types[key]; !ok </span><span class="cov8" title="1">{
                                return errors.New(fmt.Sprintf("Key does not exist in collection schema: %v", key))
                        }</span>

                        <span class="cov8" title="1">switch schemaCollection.Types[key] </span>{
                        case "STRING":<span class="cov8" title="1">
                                if _, ok := val.(string); !ok </span><span class="cov8" title="1">{
                                        return errors.New(fmt.Sprintf("Value '%v' at key '%v' in record %v does not conform to schema type %v", val, key, idx, schemaCollection.Types[key]))
                                }</span>
                        case "INT":<span class="cov8" title="1">
                                // To us it's an int value
                                // But under the hood golang is converting it to a float64 when coming from a JSON
                                // string
                                // It won't be an issue since the data gets stored as text anyway
                                if _, ok := val.(float64); !ok </span><span class="cov8" title="1">{
                                        if _, ok := val.(int); !ok </span><span class="cov8" title="1">{
                                                return errors.New(fmt.Sprintf("Value '%v' at key '%v' in record %v does not conform to schema type %v", val, key, idx, schemaCollection.Types[key]))
                                        }</span>
                                }
                        case "FLOAT":<span class="cov8" title="1">
                                if _, ok := val.(float64); !ok </span><span class="cov8" title="1">{
                                        return errors.New(fmt.Sprintf("Value '%v' at key '%v' in record %v does not conform to schema type %v", val, key, idx, schemaCollection.Types[key]))
                                }</span>
                        case "BOOL":<span class="cov8" title="1">
                                if _, ok := val.(bool); !ok </span><span class="cov8" title="1">{
                                        return errors.New(fmt.Sprintf("Value '%v' at key '%v' in record %v does not conform to schema type %v", val, key, idx, schemaCollection.Types[key]))
                                }</span>
                        case "DICT":<span class="cov8" title="1">
                                if _, ok := val.(map[string]interface{}); !ok </span><span class="cov8" title="1">{
                                        return errors.New(fmt.Sprintf("Value '%v' at key '%v' in record %v does not conform to schema type %v", val, key, idx, schemaCollection.Types[key]))
                                }</span>
                        case "LIST":<span class="cov8" title="1">
                                if _, ok := val.([]interface{}); !ok </span><span class="cov8" title="1">{
                                        return errors.New(fmt.Sprintf("Value '%v' at key '%v' in record %v does not conform to schema type %v", val, key, idx, schemaCollection.Types[key]))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package user

import (
        "ceresdb/record"
        "errors"
)

func Delete(ids []string) error <span class="cov8" title="1">{
        err := record.Delete("_auth", "_users", ids)
        return err
}</span>

func Get(ids []string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := record.Get("_auth", "_users", ids)
        return data, err
}</span>

func Patch() error <span class="cov8" title="1">{
        return errors.New("PATCH action is unsupported on resource USER")
}</span>

func Post(data []map[string]interface{}) error <span class="cov8" title="1">{
        err := record.Post("_auth", "_users", data)
        return err
}</span>

func Put(data []map[string]interface{}) error <span class="cov8" title="1">{
        err := record.Put("_auth", "_users", data)
        return err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// utils.go

package utils

import (
        "bufio"
        "sort"
)

func BuildRangeBlocks(indices []int) [][]int <span class="cov8" title="1">{
        var output [][]int
        sort.Ints(indices)

        beginIdx := indices[0]
        endIdx := indices[0]

        for _, idx := range indices[1:] </span><span class="cov8" title="1">{
                if idx == endIdx || idx == endIdx+1 </span><span class="cov8" title="1">{
                        // If there is not gap then widen the block
                        endIdx = idx
                }</span> else<span class="cov8" title="1"> {
                        // If there is a gap then record the block
                        newBlock := []int{beginIdx, endIdx}
                        output = append(output, newBlock)
                        beginIdx = idx
                        endIdx = idx
                }</span>
        }

        // Make sure we include the last block as well
        <span class="cov8" title="1">newBlock := []int{beginIdx, endIdx}
        output = append(output, newBlock)

        return output</span>
}

func CombineRangeBlocks(indices_left, indices_right [][]int) [][]int <span class="cov8" title="1">{
        combined := append(indices_left, indices_right...)
        BlockSort(combined)

        output := make([][]int, 0)
        left := combined[0][0]
        right := combined[0][1]

        for _, block := range combined[1:] </span><span class="cov8" title="1">{
                if block[0] &lt;= right </span><span class="cov8" title="1">{
                        right = block[1]
                        continue</span>
                }
                <span class="cov8" title="1">newBlock := []int{left, right}
                output = append(output, newBlock)
                left = block[0]
                right = block[1]</span>
        }
        <span class="cov8" title="1">newBlock := []int{left, right}
        output = append(output, newBlock)

        return output</span>
}

func BlockSort(arr [][]int) <span class="cov8" title="1">{
        sort.Slice(arr, func(i, j int) bool </span><span class="cov8" title="1">{
                if arr[i][0] &lt; arr[j][0] </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if arr[i][0] == arr[j][0] &amp;&amp; arr[i][1] &lt; arr[j][1] </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        })
}

func ReadLine(r *bufio.Reader) (string, error) <span class="cov8" title="1">{
        var (
                isPrefix bool  = true
                err      error = nil
                line, ln []byte
        )
        for isPrefix &amp;&amp; err == nil </span><span class="cov8" title="1">{
                line, isPrefix, err = r.ReadLine()
                ln = append(ln, line...)
        }</span>
        <span class="cov8" title="1">return string(ln), err</span>
}

func Contains(s []string, e string) bool <span class="cov8" title="1">{
        for _, a := range s </span><span class="cov8" title="1">{
                if a == e </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func RemoveDuplicateValues(stringSlice []string) []string <span class="cov0" title="0">{
        keys := make(map[string]bool)
        list := []string{}

        // If the key(values of the slice) is not equal
        // to the already present value in new slice (list)
        // then we append it. else we jump on another element.
        for _, entry := range stringSlice </span><span class="cov0" title="0">{
                if _, value := keys[entry]; !value </span><span class="cov0" title="0">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov0" title="0">return list</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
