
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ceres/config/config.go (100.0%)</option>
				
				<option value="file1">ceres/cursor/cursor.go (100.0%)</option>
				
				<option value="file2">ceres/logging/logging.go (100.0%)</option>
				
				<option value="file3">ceres/manager/manager.go (100.0%)</option>
				
				<option value="file4">ceres/utils/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// config.go

package config

import (
        log "ceres/logging"
        "encoding/json"
        "io/ioutil"
        "os"
)

type ConfigObject struct {
        LogLevel         string `json:"log-level" binding:"required"`
        CeresDir         string `json:"ceres-dir" binding:"required"`
        DataDir          string `json:"data-dir" binding:"required"`
        StorageLineLimit int    `json:"storage-line-limit" binding:"required"`
}

var Config ConfigObject

func ReadConfigFile() *ConfigObject <span class="cov8" title="1">{
        log.DEBUG("Loading Ceres configuration...")

        // Set default path if we are not passed one
        path := os.Getenv("CERES_CONFIG")
        if path == "" </span><span class="cov8" title="1">{
                path = "config/config.json"
        }</span>

        // Open our jsonFile
        <span class="cov8" title="1">jsonFile, err := os.Open(path)

        // If we os.Open returns an error then handle it
        if err != nil </span><span class="cov8" title="1">{
                log.ERROR("Unable to read json file")
                panic(err)</span>
        }

        <span class="cov8" title="1">log.INFO("Successfully Opened config/config.json")

        // Read and unmarshal the JSON
        byteValue, _ := ioutil.ReadAll(jsonFile)
        json.Unmarshal(byteValue, &amp;Config)

        defer jsonFile.Close()

        return &amp;Config</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// cursor.go

package cursor

import (
        "encoding/json"
)

type IOMode int64
type IOOp int64

const (
        ModeRead IOMode = iota
        ModeWrite
        ModeDelete
)

const (
        OpRead IOOp = iota
        OpWrite
        OpDelete
        OpNext
        OpJump
        OpError
)

var Index int
var Mode IOMode
var LowerBound int
var UpperBound int

func Initialize(lowerBound, upperBound int, mode IOMode) <span class="cov8" title="1">{
        Index = -1
        Mode = mode
        LowerBound = lowerBound
        UpperBound = upperBound
}</span>

func Next(line string, datum interface{}) (IOOp, map[string]interface{}, string, error) <span class="cov8" title="1">{
        Index += 1
        if Index &gt;= LowerBound &amp;&amp; Index &lt;= UpperBound </span><span class="cov8" title="1">{
                if Mode == ModeRead </span><span class="cov8" title="1">{
                        var outInterface map[string]interface{}
                        err := json.Unmarshal([]byte(line), &amp;outInterface)
                        if err != nil </span><span class="cov8" title="1">{
                                return OpError, nil, "", err
                        }</span>
                        <span class="cov8" title="1">return OpRead, outInterface, "", nil</span>
                } else<span class="cov8" title="1"> if Mode == ModeWrite </span><span class="cov8" title="1">{
                        var outString string
                        outBytes, err := json.Marshal(datum)
                        if err != nil </span><span class="cov8" title="1">{
                                return OpError, nil, "", err
                        }</span>
                        <span class="cov8" title="1">outString = string(outBytes) + "\n"
                        return OpWrite, nil, outString, nil</span>
                } else<span class="cov8" title="1"> if Mode == ModeDelete </span><span class="cov8" title="1">{
                        var outString string
                        outString = "\n"
                        return OpDelete, nil, outString, nil
                }</span>
        }
        <span class="cov8" title="1">if Index == UpperBound+1 </span><span class="cov8" title="1">{
                return OpNext, nil, "", nil
        }</span>
        <span class="cov8" title="1">return OpJump, nil, "", nil</span>
}

func Advance(lowerBound, upperBound int) <span class="cov8" title="1">{
        LowerBound = lowerBound
        UpperBound = upperBound
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// logging.go

package logging

import (
        log "github.com/sirupsen/logrus"
)

func Initialize(level string) <span class="cov8" title="1">{
        log.SetFormatter(&amp;log.JSONFormatter{})
        lvl, err := log.ParseLevel(level)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">log.SetLevel(lvl)</span>
}

func TRACE(message string) <span class="cov8" title="1">{
        log.Trace(message)
}</span>

func DEBUG(message string) <span class="cov8" title="1">{
        log.Debug(message)
}</span>

func INFO(message string) <span class="cov8" title="1">{
        log.Info(message)
}</span>

func WARN(message string) <span class="cov8" title="1">{
        log.Warn(message)
}</span>

func ERROR(message string) <span class="cov8" title="1">{
        log.Error(message)
}</span>

func FATAL(message string) <span class="cov8" title="1">{
        log.Fatal(message)
}</span>

func PANIC(message string) <span class="cov8" title="1">{
        log.Panic(message)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// manager.go

package manager

import (
        "bufio"
        "ceres/config"
        "ceres/cursor"
        log "ceres/logging"
        "ceres/utils"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "sort"
        "strconv"
        "strings"

        "github.com/google/uuid"
)

type FreeSpaceFile struct {
        Full   bool    `json:"full"`
        Blocks [][]int `json:"blocks"`
}

type FreeSpaceCollection struct {
        Files map[string]FreeSpaceFile
}

type FreeSpaceDatabase struct {
        Collections map[string]FreeSpaceCollection
}

type FreeSpaceStruct struct {
        Databases map[string]FreeSpaceDatabase
}

type ToWriteStruct struct {
        Data   []map[string]interface{}
        Blocks [][]int
}

var FreeSpace FreeSpaceStruct

func LoadFreeSpace() error <span class="cov8" title="1">{
        log.DEBUG("Loading free space file...")

        path := config.Config.CeresDir + "/free_space.json"

        // Open our jsonFile
        jsonFile, err := os.Open(path)

        // If we os.Open returns an error then handle it
        if err != nil </span><span class="cov8" title="1">{
                log.ERROR("Unable to read json file")
                return err
        }</span>

        <span class="cov8" title="1">log.INFO("Successfully Opened " + path)

        // Read and unmarshal the JSON
        byteValue, _ := ioutil.ReadAll(jsonFile)

        var f interface{}

        // Read the JSON
        err = json.Unmarshal(byteValue, &amp;f)
        if err != nil </span><span class="cov8" title="1">{
                log.ERROR("Unable to unmarshal json file")
                return err
        }</span>

        <span class="cov8" title="1">itemsMap := f.(map[string]interface{})
        FreeSpace.Databases = make(map[string]FreeSpaceDatabase)

        // Loop through the top-level items (database names)
        for dbKey, dbVal := range itemsMap </span><span class="cov8" title="1">{
                dbItem := FreeSpaceDatabase{}
                dbItem.Collections = make(map[string]FreeSpaceCollection)
                dbItemsMap := dbVal.(map[string]interface{})

                // Loop through the 2nd-level items (collection names)
                for colKey, colVal := range dbItemsMap </span><span class="cov8" title="1">{
                        colItem := FreeSpaceCollection{}
                        colItem.Files = make(map[string]FreeSpaceFile)
                        colItemsMap := colVal.(map[string]interface{})

                        // Loop through the 3rd-level items (file names)
                        for fileKey, fileVal := range colItemsMap </span><span class="cov8" title="1">{
                                fileItem := FreeSpaceFile{}
                                fileItemsMap := fileVal.(map[string]interface{})
                                fileItem.Full = fileItemsMap["full"].(bool)
                                blocksItem := make([][]int, 0)
                                blocksItemList := fileItemsMap["blocks"].([]interface{})

                                // Loop through the block items
                                for _, blockVal := range blocksItemList </span><span class="cov8" title="1">{
                                        blockItem := make([]int, 0)
                                        blockItemList := blockVal.([]interface{})
                                        for _, idxVal := range blockItemList </span><span class="cov8" title="1">{
                                                blockItem = append(blockItem, int(idxVal.(float64)))
                                        }</span>
                                        <span class="cov8" title="1">blocksItem = append(blocksItem, blockItem)</span>
                                }

                                <span class="cov8" title="1">fileItem.Blocks = blocksItem
                                colItem.Files[fileKey] = fileItem</span>
                        }
                        <span class="cov8" title="1">dbItem.Collections[colKey] = colItem</span>
                }
                <span class="cov8" title="1">FreeSpace.Databases[dbKey] = dbItem</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func read(dbIdent, colIdent, fileIdent string, blocks [][]int) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        blockIdx := 0
        blockLen := len(blocks)
        cursor.Initialize(blocks[0][0], blocks[0][1], cursor.ModeRead)
        output := make([]map[string]interface{}, 0)

        path := config.Config.DataDir + "/" + dbIdent + "/" + colIdent + "/" + fileIdent
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                log.ERROR("Could not open file: " + path)
                return nil, err
        }</span>
        <span class="cov8" title="1">r := bufio.NewReader(f)
        s, e := utils.ReadLine(r)
        for e == nil </span><span class="cov8" title="1">{
                op, dat, _, err := cursor.Next(s, nil)
                if err != nil </span><span class="cov8" title="1">{
                        log.ERROR("Cursor error")
                        return nil, err
                }</span>
                <span class="cov8" title="1">switch op </span>{
                case cursor.OpRead:<span class="cov8" title="1">
                        output = append(output, dat)</span>
                case cursor.OpNext:<span class="cov8" title="1">
                        blockIdx += 1
                        if blockIdx == blockLen </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">cursor.Advance(blocks[blockIdx][0], blocks[blockIdx][1])</span>
                }
                <span class="cov8" title="1">s, e = utils.ReadLine(r)</span>
        }
        <span class="cov8" title="1">return output, nil</span>
}

func write(dbIdent, colIdent, fileIdent string, blocks [][]int, data []map[string]interface{}) error <span class="cov8" title="1">{
        blockIdx := 0
        dataIdx := 0
        dataLen := len(data)
        cursor.Initialize(blocks[0][0], blocks[0][1], cursor.ModeWrite)
        newContents := make([]string, 0)

        path := config.Config.DataDir + "/" + dbIdent + "/" + colIdent + "/" + fileIdent
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                log.ERROR("Could not open file: " + path)
                return err
        }</span>
        <span class="cov8" title="1">r := bufio.NewReader(f)
        s, e := utils.ReadLine(r)
        for e == nil </span><span class="cov8" title="1">{
                if dataIdx &lt; dataLen </span><span class="cov8" title="1">{
                        data[dataIdx][".id"] = fmt.Sprintf("%s-%d", fileIdent, cursor.Index+1)
                        op, _, dat, err := cursor.Next(s, data[dataIdx])
                        if err != nil </span><span class="cov8" title="1">{
                                log.ERROR("Cursor error")
                                return err
                        }</span>
                        <span class="cov8" title="1">switch op </span>{
                        case cursor.OpWrite:<span class="cov8" title="1">
                                newContents = append(newContents, dat)
                                dataIdx += 1</span>
                        case cursor.OpJump:<span class="cov8" title="1">
                                newContents = append(newContents, s+"\n")</span>
                        case cursor.OpNext:<span class="cov8" title="1">
                                blockIdx += 1
                                newContents = append(newContents, s+"\n")
                                cursor.Advance(blocks[blockIdx][0], blocks[blockIdx][1])</span>
                        }
                } else<span class="cov8" title="1"> {
                        newContents = append(newContents, s+"\n")
                }</span>
                <span class="cov8" title="1">s, e = utils.ReadLine(r)</span>
        }

        // Write out the new contents
        <span class="cov8" title="1">output := strings.Join(newContents[:], "")
        f, _ = os.Create(path)
        defer f.Close()
        f.Write([]byte(output))

        return nil</span>
}

func delete(dbIdent, colIdent, fileIdent string, blocks [][]int) error <span class="cov8" title="1">{
        blockIdx := 0
        blockLen := len(blocks)
        cursor.Initialize(blocks[0][0], blocks[0][1], cursor.ModeDelete)
        newContents := make([]string, 0)

        path := config.Config.DataDir + "/" + dbIdent + "/" + colIdent + "/" + fileIdent
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                log.ERROR("Could not open file: " + path)
                return err
        }</span>
        <span class="cov8" title="1">r := bufio.NewReader(f)
        s, e := utils.ReadLine(r)
        for e == nil </span><span class="cov8" title="1">{
                op, _, dat, _ := cursor.Next(s, nil)
                switch op </span>{
                case cursor.OpDelete:<span class="cov8" title="1">
                        newContents = append(newContents, dat)</span>
                case cursor.OpJump:<span class="cov8" title="1">
                        newContents = append(newContents, s+"\n")</span>
                case cursor.OpNext:<span class="cov8" title="1">
                        blockIdx += 1
                        newContents = append(newContents, s+"\n")
                        if blockIdx == blockLen </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">cursor.Advance(blocks[blockIdx][0], blocks[blockIdx][1])</span>
                }
                <span class="cov8" title="1">s, e = utils.ReadLine(r)</span>
        }

        // Write out the new contents
        <span class="cov8" title="1">output := strings.Join(newContents[:], "")
        f, _ = os.Create(path)
        defer f.Close()
        f.Write([]byte(output))

        return nil</span>
}

func Read(database, collection string, ids []string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        output := make([]map[string]interface{}, 0)
        toRead := make(map[string][]int)

        // Determine which IDs from which files should be read
        for _, id := range ids </span><span class="cov8" title="1">{
                parts := strings.Split(id, "-")
                if val, ok := toRead[parts[0]]; ok </span><span class="cov8" title="1">{
                        idx, _ := strconv.Atoi(parts[1])
                        toRead[parts[0]] = append(val, idx)
                }</span> else<span class="cov8" title="1"> {
                        idx, _ := strconv.Atoi(parts[1])
                        toRead[parts[0]] = []int{idx}
                }</span>
        }

        // Build up range blocks
        <span class="cov8" title="1">for key, val := range toRead </span><span class="cov8" title="1">{
                blocks := utils.BuildRangeBlocks(val)
                data, err := read(database, collection, key, blocks)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">output = append(output, data...)</span>
        }

        <span class="cov8" title="1">return output, nil</span>
}

func Write(database, collection string, data []map[string]interface{}) error <span class="cov8" title="1">{
        recordsRemaining := len(data)
        toWrite := make(map[string]ToWriteStruct)

        db := FreeSpace.Databases[database]
        col := db.Collections[collection]

        keys := make([]string, 0, len(col.Files))
        for k := range col.Files </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        for _, key := range keys </span><span class="cov8" title="1">{
                val := col.Files[key]
                // If the file is not full
                if !val.Full </span><span class="cov8" title="1">{
                        // Direct data to be written to the file
                        writable := ToWriteStruct{Blocks: make([][]int, 0), Data: make([]map[string]interface{}, 0)}
                        for _, block := range val.Blocks </span><span class="cov8" title="1">{
                                log.INFO(fmt.Sprintf("Block size: %d", recordsRemaining))
                                blockSize := block[1] - block[0] + 1
                                if recordsRemaining &gt;= blockSize </span><span class="cov8" title="1">{
                                        // Handle more records than is available in the block
                                        writable.Blocks = append(writable.Blocks, []int{block[0], block[1]})
                                        writable.Data = append(writable.Data, data[:blockSize]...)
                                        data = data[blockSize:]
                                        recordsRemaining -= blockSize
                                        val.Blocks = val.Blocks[1:]
                                        continue</span>
                                } else<span class="cov8" title="1"> {
                                        // Handle a larger block than there are records available
                                        writable.Blocks = append(writable.Blocks, []int{block[0], block[0] + recordsRemaining - 1})
                                        writable.Data = append(writable.Data, data...)
                                        block[0] = block[0] + recordsRemaining
                                        recordsRemaining = 0
                                        val.Blocks[0] = block
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">toWrite[key] = writable
                        if len(val.Blocks) == 0 </span><span class="cov8" title="1">{
                                val.Full = true
                        }</span>
                        <span class="cov8" title="1">col.Files[key] = val</span>
                }
                <span class="cov8" title="1">if recordsRemaining == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // Handle overflow
        <span class="cov8" title="1">for recordsRemaining &gt; 0 </span><span class="cov8" title="1">{
                id := uuid.New().String()
                val := FreeSpaceFile{Full: false, Blocks: [][]int{{0, config.Config.StorageLineLimit - 1}}}
                path := config.Config.DataDir + "/" + database + "/" + collection + "/" + id
                // Write out the new contents
                output := ""
                for idx := 0; idx &lt; 32; idx++ </span><span class="cov8" title="1">{
                        output += "\n"
                }</span>
                <span class="cov8" title="1">f, _ := os.Create(path)
                f.Write([]byte(output))
                f.Close()
                writable := ToWriteStruct{Blocks: make([][]int, 0), Data: make([]map[string]interface{}, 0)}
                for _, block := range val.Blocks </span><span class="cov8" title="1">{
                        blockSize := block[1] - block[0] + 1
                        if recordsRemaining &gt;= blockSize </span><span class="cov8" title="1">{
                                // Handle more records than is available in the block
                                writable.Blocks = append(writable.Blocks, []int{block[0], block[1]})
                                writable.Data = append(writable.Data, data[:blockSize]...)
                                data = data[blockSize:]
                                recordsRemaining -= blockSize
                                val.Blocks = val.Blocks[1:]
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                // Handle a larger block than there are records available
                                writable.Blocks = append(writable.Blocks, []int{block[0], block[0] + recordsRemaining - 1})
                                writable.Data = append(writable.Data, data...)
                                block[0] = block[0] + recordsRemaining
                                recordsRemaining = 0
                                val.Blocks[0] = block
                                break</span>
                        }
                }
                <span class="cov8" title="1">toWrite[id] = writable
                if len(val.Blocks) == 0 </span><span class="cov8" title="1">{
                        val.Full = true
                }</span>
                <span class="cov8" title="1">col.Files[id] = val</span>
        }

        <span class="cov8" title="1">db.Collections[collection] = col
        FreeSpace.Databases[database] = db

        for key, val := range toWrite </span><span class="cov8" title="1">{
                err := write(database, collection, key, val.Blocks, val.Data)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func Delete(database, collection string, ids []string) error <span class="cov8" title="1">{
        toDelete := make(map[string][]int)

        // Determine which IDs from which files should be read
        for _, id := range ids </span><span class="cov8" title="1">{
                parts := strings.Split(id, "-")
                if val, ok := toDelete[parts[0]]; ok </span><span class="cov8" title="1">{
                        idx, _ := strconv.Atoi(parts[1])
                        toDelete[parts[0]] = append(val, idx)
                }</span> else<span class="cov8" title="1"> {
                        idx, _ := strconv.Atoi(parts[1])
                        toDelete[parts[0]] = []int{idx}
                }</span>
        }

        <span class="cov8" title="1">db := FreeSpace.Databases[database]
        col := db.Collections[collection]

        // Build up range blocks
        for key, val := range toDelete </span><span class="cov8" title="1">{
                blocks := utils.BuildRangeBlocks((val))
                err := delete(database, collection, key, blocks)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Record newly available free space
                <span class="cov8" title="1">fi := col.Files[key]
                fi.Full = false
                fi.Blocks = utils.CombineRangeBlocks(utils.BuildRangeBlocks(val), fi.Blocks)
                col.Files[key] = fi</span>
        }

        <span class="cov8" title="1">db.Collections[collection] = col
        FreeSpace.Databases[database] = db

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// utils.go

package utils

import (
        "bufio"
        "sort"
)

func BuildRangeBlocks(indices []int) [][]int <span class="cov8" title="1">{
        var output [][]int
        sort.Ints(indices)

        beginIdx := indices[0]
        endIdx := indices[0]

        for _, idx := range indices[1:] </span><span class="cov8" title="1">{
                if idx == endIdx || idx == endIdx+1 </span><span class="cov8" title="1">{
                        // If there is not gap then widen the block
                        endIdx = idx
                }</span> else<span class="cov8" title="1"> {
                        // If there is a gap then record the block
                        newBlock := []int{beginIdx, endIdx}
                        output = append(output, newBlock)
                        beginIdx = idx
                        endIdx = idx
                }</span>
        }

        // Make sure we include the last block as well
        <span class="cov8" title="1">newBlock := []int{beginIdx, endIdx}
        output = append(output, newBlock)

        return output</span>
}

func CombineRangeBlocks(indices_left, indices_right [][]int) [][]int <span class="cov8" title="1">{
        combined := append(indices_left, indices_right...)
        BlockSort(combined)

        output := make([][]int, 0)
        left := combined[0][0]
        right := combined[0][1]

        for _, block := range combined[1:] </span><span class="cov8" title="1">{
                if block[0] &lt;= right </span><span class="cov8" title="1">{
                        right = block[1]
                        continue</span>
                }
                <span class="cov8" title="1">newBlock := []int{left, right}
                output = append(output, newBlock)
                left = block[0]
                right = block[1]</span>
        }
        <span class="cov8" title="1">newBlock := []int{left, right}
        output = append(output, newBlock)

        return output</span>
}

func BlockSort(arr [][]int) <span class="cov8" title="1">{
        sort.Slice(arr, func(i, j int) bool </span><span class="cov8" title="1">{
                if arr[i][0] &lt; arr[j][0] </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if arr[i][0] == arr[j][0] &amp;&amp; arr[i][1] &lt; arr[j][1] </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        })
}

func ReadLine(r *bufio.Reader) (string, error) <span class="cov8" title="1">{
        var (
                isPrefix bool  = true
                err      error = nil
                line, ln []byte
        )
        for isPrefix &amp;&amp; err == nil </span><span class="cov8" title="1">{
                line, isPrefix, err = r.ReadLine()
                ln = append(ln, line...)
        }</span>
        <span class="cov8" title="1">return string(ln), err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
